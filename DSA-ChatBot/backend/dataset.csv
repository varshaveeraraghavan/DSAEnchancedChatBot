question,answer
What is an array?,"An array is a data structure consisting of a collection of elements, each identified by at least one array index or key."
Can an array be resized at runtime?,"In some programming languages, arrays can be resized dynamically, while in others, such as C, the size is fixed."
What is the time complexity for accessing an element in an array?,"The time complexity for accessing an element in an array is O(1), as it can be accessed directly using its index."
What is the difference between an array and a linked list?,"An array is a static data structure, while a linked list is a dynamic data structure. Arrays have a fixed size, and elements are stored consecutively in memory, while linked lists can grow and do not require contiguous memory allocation."
How would you find the smallest and largest element in an array?,"To find the smallest and largest elements in an array, one common approach is to iterate through the array and keep track of the smallest and largest elements encountered so far."
Explain the concept of a multi-dimensional array.,"A multi-dimensional array is an array that contains other arrays. For example, a 2D array is an array of arrays, representing a matrix."
What is an array index out of bounds exception?,"This error occurs when an attempt is made to access an element at an index that is outside the bounds of the array (e.g., negative index or greater than the array size)."
How would you reverse an array in-place in linear time and constant space?, One approach is to use two pointers starting from the beginning and end of the array and swap the elements until they meet in the middle.
Explain the concept of a jagged array.,"A jagged array is an array of arrays, where each sub-array could be of a different length."
How can you find duplicate elements in an array?,One way to find duplicate elements in an array is to use a hash set or to sort the array and then iterate through it to find consecutive duplicates.
Discuss the advantages and disadvantages of using arrays.,"Advantages: Constant time access, simple implementation, and efficient storage for contiguous data.
Disadvantages: Fixed size, no support for dynamic growth, inefficient for insertions and deletions."
Explain the concept of a sparse array.,A sparse array is an array in which most of the elements have the same value. It can be represented using a data structure that only stores the non-default (non-zero) values.
What is the difference between an array and a list?,"An array is a static data structure with a fixed size, while a list is a dynamic data structure that can grow and shrink during runtime."
What is a linked list?,"A linked list is a linear data structure consisting of a sequence of elements, where each element points to the next one, forming a chain."
What are the different types of linked lists?,"Singly linked list, doubly linked list, and circular linked list."
What are the advantage of Linked List?,"Advantages of Linked Lists:
Dynamic memory allocation
Efficient insertion and deletion
Can represent complex data structures
Can be used to implement queues and stacks
Can be used for memory management and caching
Can be used for garbage collection"
What are the disadvantage of Linked List?,"Disadvantages of Linked Lists:
Slow random access
More memory overhead
Difficult to debug
Not cache-friendly
Can suffer from memory leaks"
What is a cycle/loop in Singly Linked List:,"A cycle, also known as a loop, in a singly-linked list occurs when a node in the list points back to a previous node, creating a circular path. This means that if you start traversing the list from any node, you will eventually come back to the same node, forming an infinite loop."
What is time complexity of Linked List operations?,"The time complexity of common operations on a singly-linked list are as follows:
Insertion:
At the beginning: O(1)
At the end: O(n)
At a specific position: O(n)
Deletion:
At the beginning: O(1)
At the end: O(n)
At a specific position: O(n)
Search: O(n)
Traversal: O(n)"
How would you compare Dynamic Arrays Vs Linked Lists?,"Dynamic Array Advantages:
Fast random access (O(1))
Efficient for large data sets
Contiguous memory allocation
Dynamic Array Disadvantages:
Slow insertion and deletion in the middle (O(n))
Fixed size, can lead to memory waste or reallocation
Linked Lists Advantages:
Efficient insertion and deletion in the middle (O(1))
Can grow and shrink dynamically
Can represent complex data structures
Linked Lists Disadvantages:
Slow random access (O(n))
More memory overhead due to pointers
Not cache-friendly
Dynamic arrays are more efficient for random access and large data sets, while linked lists are more efficient for operations that involve insertion and deletion in the middle. Linked lists are also more flexible and can represent complex data structures."
What is a stack?,"A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle, where the last element added is the first one to be removed. It has two main operations: push, which adds an element to the top of the stack, and pop, which removes the top element from the stack."
What are the operations performed on a stack?,"The common operations on a stack are push (insert an element), pop (remove the top element), and peek (view the top element)."
How is a stack implemented in an array?,A stack can be implemented using an array by maintaining a pointer to the top of the stack.
What is the time complexity of stack operations?,"Push, pop, and peek operations have a time complexity of O(1)."
What are the applications of a stack?,"Stacks are used in various applications, such as function calls, recursion, expression evaluation, and parsing."
What is a stack overflow?,A stack overflow occurs when the stack exceeds its allocated memory.
What is a stack underflow?,A stack underflow occurs when the stack is empty and an attempt is made to pop an element.
What is a postfix expression?,A postfix expression is an expression where the operator follows the operands.
How can a stack be used to evaluate a postfix expression?,By pushing operands onto the stack and performing operations when operators are encountered.
What is a prefix expression?,A prefix expression is an expression where the operator precedes the operands.
How can a stack be used to evaluate a prefix expression?,By pushing operators onto the stack and performing operations when operands are encountered.
How can a stack be used to check if a parenthesis expression is balanced?,"A stack can be used to check if a parenthesis expression is balanced by following these steps:
Push the opening parenthesis onto the stack.
When an closing parenthesis is encountered, pop the top element from the stack and check if it matches the closing parenthesis.
If the stack is empty at the end of the expression, then the expression is balanced.
If the stack is not empty, then the expression is not balanced."
Where are stacks used?,"Expression, evaluation, or conversion of evaluating prefix, postfix, and infix expressions
Syntax parsing
String reversal
Parenthesis checking
Backtracking"
What is a Queue?,"A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle, where elements are added at the rear (enqueue) and removed from the front (dequeue)."
What are the different types of Queues?,"Simple Queue
Circular Queue
Priority Queue
Double-Ended Queue (Deque)"
How is a Queue implemented in an array?,"An array can be used to implement a simple queue by maintaining two pointers: front and rear. Front points to the first element, and rear points to the next available position."
How is a Queue implemented in a linked list?,"A linked list can be used to implement a queue by creating a node for each element and maintaining a head and tail pointer. Enqueueing adds a node to the tail, and dequeueing removes a node from the head."
What is the time complexity of enqueue and dequeue operations in a Queue?,"Enqueue: O(1)
Dequeue: O(1) for simple and circular queues, O(n) for priority queues"
What is the difference between a Queue and a Stack?,"A queue follows FIFO, while a stack follows Last-In-First-Out (LIFO)."
What are the applications of Queues?,"Task scheduling
Message passing
Simulation of real-world scenarios"
How do you handle overflow and underflow conditions in a Queue?,"Overflow: When the queue is full, throw an exception or return an error code.
Underflow: When the queue is empty, throw an exception or return a null value."
What is a circular queue?,A circular queue is a variation of a simple queue where the rear pointer wraps around to the beginning of the array after reaching the end.
What is a priority queue?,A priority queue is a queue where elements are assigned priorities and are dequeued based on their priorities.
How is a priority queue implemented?,Priority queues can be implemented using a binary heap or a self-balancing binary search tree.
What is a double-ended queue (Deque)?,A deque is a queue that allows insertions and deletions from both ends.
How is a deque implemented?,A deque can be implemented using two stacks or a circular buffer.
What are the advantages of using a Queue?,"Simple and efficient FIFO implementation
Easy to enqueue and dequeue elements
Supports multiple producers and consumers"
What are the disadvantages of using a Queue?,"Limited access to elements (only from the front or rear)
Can be inefficient if elements need to be accessed in a non-sequential order"
What is a heap data structure?,A heap is a complete binary tree that satisfies the heap property: each node’s value is greater than or equal to its children’s values.
What are the two types of heaps?,"Max-heap and min-heap. In a max-heap, the root node has the maximum value, while in a min-heap, the root node has the minimum value."
What is the time complexity of inserting an element into a heap?,"O(log n), where n is the number of elements in the heap."
What is the time complexity of deleting an element from a heap?,"O(log n), where n is the number of elements in the heap."
What is the time complexity of finding the minimum or maximum element in a heap?,"O(1), as the root node always contains the minimum or maximum element."
What are the applications of heaps?,"Heap applications: Priority queues,Sorting, Finding the median, Implementing Dijkstra’s algorithm, Network routing, Huffman coding"
What is the difference between a heap and a binary search tree (BST)?,"A heap is a complete binary tree that satisfies the heap property, while a BST is a partially ordered binary tree that satisfies the BST property."
How do you convert a BST into a heap?,By performing an in-order traversal of the BST and inserting the elements into a heap.
How do you merge two heaps?,By creating a new heap and inserting the elements from both heaps into the new heap while maintaining the heap property.
What is the difference between a heap and a priority queue?,"A heap is a data structure, while a priority queue is an abstract data type that can be implemented using a heap."
What are the advantages of using a heap?,"Advantages of using a heap:
Efficient insertion and extraction (O(log n))
Can be used to implement priority queues
Can be used for sorting (O(n log n))
Useful for other applications, such as finding the median and implementing Dijkstra’s algorithm"
What is a hash data structure?,"A hash data structure is a data structure that stores key-value pairs, where the keys are hashed to determine the location of the value in the data structure."
What is a hash table?,"A hash table is a data structure that implements an associative array, allowing fast retrieval of values based on unique keys. It uses a hash function to map keys to indices in an array, providing constant-time average access (O(1)) if collisions are minimized."
What is a hash function?,A hash function is a function that takes an input of any size and produces an output of a fixed size. The output is called a hash value or hash code.
Explain how a hash function works.,"A hash function takes an input key and maps it to a fixed-size index (hash value) within the hash table’s array. Ideally, the function distributes keys evenly across the array to minimize collisions. Common hash functions include modulo division, bitwise operations, and polynomial hashing."
What is a collision?,A collision occurs when two different keys hash to the same value.
Describe different collision resolution techniques.,"Open addressing: Use probing techniques (linear, quadratic, double hashing) to find the next available slot when a collision occurs.
Separate chaining: Store key-value pairs in linked lists at each index, leading to better performance for larger data sets."
How are collisions handled in a hash data structure?,"Collisions can be handled using various techniques, such as chaining, open addressing, and cuckoo hashing."
What is chaining?,Chaining is a collision resolution technique where colliding keys are stored in a linked list at the same hash value.
What is open addressing?,"Open addressing is a collision resolution technique where colliding keys are stored in the same hash table, but at different locations."
What is separate chaining?," Separate chaining is a collision resolution technique used in hash tables. When two or more keys hash to the same index in the hash table, instead of overwriting the existing data, separate chaining stores each key-value pair in a linked list at that index. This allows for efficient retrieval of all elements that hash to the same index, even if there are collisions."
What are the trade-offs between open addressing and separate chaining?,"Open addressing: Less memory overhead, but search performance degrades with collisions.
Separate chaining: More memory usage, but faster search performance even with collisions."
What is cuckoo hashing?,Cuckoo hashing is a collision resolution technique that uses two hash functions to store keys in a hash table.
What is the load factor of a hash table?,The load factor of a hash table is the ratio of the number of keys stored in the table to the size of the table.
What is the optimal load factor for a hash table?,"The optimal load factor for a hash table depends on the collision resolution technique used, but it is typically around 0.7."
Explain the concept of load factor and its impact on performance.,Load factor (number of elements / size of hash table) measures how full the table is. Higher load factors increase collision frequency and impact performance. Optimal values vary based on implementation and trade-offs.
What are the advantages of using a hash data structure?,"Hash data structures offer fast lookup, insertion, and deletion operations. They are also space-efficient and can handle large datasets."
What are the disadvantages of using a hash data structure?,"Hash data structures can suffer from collisions, which can slow down lookup operations. They also require a hash function that is both efficient and effective."
Explain bloom filters and their applications.,"Bloom filters use multiple hash functions to probabilistically represent set membership, offering efficient space-time trade-offs for membership queries but not supporting direct value retrieval. Used in caching, network security, and other applications."
What is a Tree?,"A tree is a non-linear data structure consisting of nodes connected by edges. Each node contains data and references to its child nodes. It has one special node called the root, with no parent, and leaf nodes with no children."
Explain different types of trees.,"Binary Tree: Each node has at most two children (left and right).
Full Binary Tree: Every node except leaves has two children.
Complete Binary Tree: All levels are filled except possibly the last, and nodes are filled left to right.
Perfect Binary Tree: Every node has two children, and all leaves are at the same level.
AVL Tree: Self-balancing binary search tree with a height difference of at most 1 between subtrees.
Red-Black Tree: Self-balancing binary search tree with specific coloring rules to maintain balance.
B-Tree: Generalization of a binary search tree with more than two children per node."
What are the basic operations performed on a tree?,"Insertion: Add a new node to the tree while maintaining its properties (e.g., ordering in search trees).
Deletion: Remove a node from the tree while preserving its structure.
Traversal: Visit each node in the tree exactly once in a specific order (preorder, inorder, postorder).
Searching: Find a specific node with a given value based on search criteria."
What are the different ways to represent a tree in memory?,"Node-based representation: Each node stores its data and references to child nodes.
Array-based representation: Use an array to store node data with calculations to find child nodes based on their positions."
What are the advantages and disadvantages of using trees?,"Advantages:
Efficient for hierarchical data representation and organization.
Fast searching and traversal in balanced trees.
Disadvantages:
Memory overhead due to storing pointers or references.
Not efficient for storing large amounts of unstructured data."
When would you choose a tree over other data structures like arrays or linked lists?,"Trees are ideal for hierarchical data, maintaining relationships between elements, and efficient searching based on order. Arrays or linked lists are better for simple linear data or frequent insertions/deletions at specific positions."
Explain the concept of a binary search tree.,"A binary search tree has a specific ordering property: the data in the left subtree is less than the root, and the data in the right subtree is greater than the root. This allows for efficient searching by comparing values with the root and navigating left or right accordingly."
How do self-balancing trees like AVL or Red-Black trees work?,"These trees automatically adjust their structure after insertions or deletions to maintain a balanced height, ensuring efficient search and insertion/deletion operations. They achieve this through specific rules and rotations based on node heights and colors."
"Describe the different tree traversal methods (preorder, inorder, postorder).","Preorder: Visit root, then left subtree, then right subtree.
Inorder: Visit left subtree, then root, then right subtree.
Postorder: Visit left subtree, then right subtree, then root.
Each traversal method has different purposes. Inorder is useful for printing sorted elements in a binary search tree, while preorder might be used for copying tree structure."
How can you convert a binary search tree into a sorted array?,"One efficient way is to use an inorder traversal of the tree. Since the tree is sorted, visiting nodes in this order will result in a sorted array."
Explain the concept of a minimum spanning tree.,"A minimum spanning tree is a subgraph of a connected, undirected graph that includes all vertices but with the minimum total edge weight, connecting all nodes without cycles. It has applications in network routing and clustering algorithms."
Describe the use of trees in real-world scenarios.,"Trees are used in various domains, including:
File systems (directory structure)
XML or JSON data representation
Decision trees for machine learning
Game AI (representing game states and possible actions)
Social networks (representing user relationships"
What is a graph?,"A graph is a data structure consisting of a set of vertices (nodes) and a set of edges that connect pairs of vertices. Graphs are used to represent relationships between objects, such as social networks, road networks, and computer networks."
Explain common graph representations.,"Adjacency matrix: A 2D array where rows and columns represent nodes, and values indicate the existence of an edge between them. Efficient for space usage, but can be slow for sparse graphs.
Adjacency list: An array of linked lists or other data structures, where each list stores nodes connected to a specific node. Efficient for sparse graphs and adjacency queries, but may require more space."
Differentiate between directed and undirected graphs.,"Directed graphs: Edges have a direction, signifying one-way relationships.
Undirected graphs: Edges have no direction, representing bidirectional relationships."
Describe common graph types.,"Simple graphs: Undirected, no loops or multiple edges between nodes.
Complete graphs: Every node is connected to every other node.
Trees: No cycles, a single root node connects to child nodes that don’t form cycles.
Bipartite graphs: Can be divided into two disjoint sets where only nodes in different sets connect."
Discuss time and space complexity of basic graph operations.,"Traversal (DFS, BFS): O(V + E) for both time and space, where V is the number of nodes and E is the number of edges.
Insertion: O(1) for constant-time operations in both adjacency list and matrix, although insertion into sparse matrices requiring reallocation might have amortized cost.
Deletion: O(degree of the node) for adjacency lists, O(V^2) for adjacency matrices due to potential row/column shifts."
Explain Dijkstra’s algorithm and its applications.,"This algorithm finds the shortest path between two nodes in a weighted graph. It is used in route planning, network optimization, and other problems involving finding minimum-cost paths."
"Compare DFS and BFS algorithms: strengths, weaknesses, and use cases.","DFS: Explores deeply before exploring breadth-wise, efficient for finding connected components, good for detecting cycles.
BFS: Explores breadth-wise, efficient for finding shortest paths in unweighted graphs, useful for level-order traversals."
Describe topological sorting: algorithm and applications.,"Topological sorting: Orders nodes such that edges always point from earlier nodes to later ones, required for tasks with dependencies.
Application: Used in job scheduling, software dependency management, and circuit design."
Explain minimum spanning trees: algorithms and their significance.,"Minimum spanning trees: Finds a subset of edges that connects all nodes with minimum total weight while avoiding cycles.
Significance: Used in network communication, clustering."
Give implementation of Kadane's algorithm ,"import java.io.*;
import java.util.*;
 
class Kadane {
    // Driver Code
    public static void main(String[] args)
    {
        int[] a = { -2, -3, 4, -1, -2, 1, 5, -3 };
        System.out.println(""Maximum contiguous sum is ""
                           + maxSubArraySum(a));
    }
 
    // Function Call
    static int maxSubArraySum(int a[])
    {
        int size = a.length;
        int max_so_far = Integer.MIN_VALUE, max_ending_here
                                            = 0;
 
        for (int i = 0; i < size; i++) {
            max_ending_here = max_ending_here + a[i];
            if (max_so_far < max_ending_here)
                max_so_far = max_ending_here;
            if (max_ending_here < 0)
                max_ending_here = 0;
        }
        return max_so_far;
    }
}"
"Given a matrix, your task is to rotate the matrix 90 degrees clockwise.","Code in Java:
import java.util.*;
class Main {
    static void rotate(int[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = i; j < matrix[0].length; j++) {
                int temp = 0;
                temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix.length / 2; j++) {
                int temp = 0;
                temp = matrix[i][j];
                matrix[i][j] = matrix[i][matrix.length - 1 - j];
                matrix[i][matrix.length - 1 - j] = temp;
            }
        }
    }

    public static void main(String args[]) {
        int arr[][] =  {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        rotate(arr);
        System.out.println(""Rotated Image"");
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length; j++) {
                System.out.print(arr[i][j] + "" "");
            }
            System.out.println();
        }

    }
}

Complexity Analysis
Time Complexity: O(N*N) + O(N*N).One O(N*N) is for transposing the matrix and the other is for reversing the matrix.

Space Complexity: O(1)."
"Given an array of intervals, merge all the overlapping intervals and return an array of non-overlapping intervals.","Code in Java: 
import java.util.*;

public class Main {

    public static List<List<Integer>> mergeOverlappingIntervals(int[][] arr) {
        int n = arr.length; // size of the array
        //sort the given intervals:
        Arrays.sort(arr, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return a[0] - b[0];
            }
        });

        List<List<Integer>> ans = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            // if the current interval does not
            // lie in the last interval:
            if (ans.isEmpty() || arr[i][0] > ans.get(ans.size() - 1).get(1)) {
                ans.add(Arrays.asList(arr[i][0], arr[i][1]));
            }
            // if the current interval
            // lies in the last interval:
            else {
                ans.get(ans.size() - 1).set(1,
                                            Math.max(ans.get(ans.size() - 1).get(1), arr[i][1]));
            }
        }
        return ans;
    }

    public static void main(String[] args) {
        int[][] arr = {{1, 3}, {8, 10}, {2, 6}, {15, 18}};
        List<List<Integer>> ans = mergeOverlappingIntervals(arr);
        System.out.print(""The merged intervals are: \n"");
        for (List<Integer> it : ans) {
            System.out.print(""["" + it.get(0) + "", "" + it.get(1) + ""] "");
        }
        System.out.println();
    }
}
Time Complexity: O(N*logN) + O(N), where N = the size of the given array.
Reason: Sorting the given array takes  O(N*logN) time complexity. Now, after that, we are just using a single loop that runs for N times. So, the time complexity will be O(N).

Space Complexity: O(N), as we are using an answer list to store the merged intervals. Except for the answer array, we are not using any extra space.
"
"Merge two Sorted Arrays Without Extra Space
Given two sorted arrays arr1[] and arr2[] of sizes n and m in non-decreasing order. Merge them in sorted order. Modify arr1 so that it contains the first N elements and modify arr2 so that it contains the last M elements.","Code in Java:

import java.util.*;

public class Main {

    public static void merge(long[] arr1, long[] arr2, int n, int m) {

        // Declare 2 pointers:
        int left = n - 1;
        int right = 0;

        // Swap the elements until arr1[left] is
        // smaller than arr2[right]:
        while (left >= 0 && right < m) {
            if (arr1[left] > arr2[right]) {
                long temp = arr1[left];
                arr1[left] = arr2[right];
                arr2[right] = temp;
                left--;
                right++;
            } else {
                break;
            }
        }

        // Sort arr1[] and arr2[] individually:
        Arrays.sort(arr1);
        Arrays.sort(arr2);
    }

    public static void main(String[] args) {
        long[] arr1 = {1, 4, 8, 10};
        long[] arr2 = {2, 3, 9};
        int n = 4, m = 3;
        merge(arr1, arr2, n, m);
        System.out.println(""The merged arrays are:"");
        System.out.print(""arr1[] = "");
        for (int i = 0; i < n; i++) {
            System.out.print(arr1[i] + "" "");
        }
        System.out.print(""\narr2[] = "");
        for (int i = 0; i < m; i++) {
            System.out.print(arr2[i] + "" "");
        }
        System.out.println();
    }

}
Time Complexity: O(min(n, m)) + O(n*logn) + O(m*logm), where n and m are the sizes of the given arrays.
Reason: O(min(n, m)) is for swapping the array elements. And O(n*logn) and O(m*logm) are for sorting the two arrays.

Space Complexity: O(1) as we are not using any extra space.
"
"Find the duplicate in an array of N+1 integers


Given an array of N + 1 size, where each element is between 1 and N. Assuming there is only one duplicate number, your task is to find the duplicate number.","Code in Java:import java.util.*;
class Main {
    public static int findDuplicate(int[] nums) {
        int slow = nums[0];
        int fast = nums[0];
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        fast = nums[0];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
    public static void main(String args[]) {
        int arr[] = {1,3,4,2,3};
        System.out.println(""The duplicate element is "" + findDuplicate(arr));
    }
}Time complexity: O(N). Since we traversed through the array only once.

Space complexity: O(1).

"
"Find the repeating and missing numbers

 You are given a read-only array of N integers with values also in the range [1, N] both inclusive. Each integer appears exactly once except A which appears twice and B which is missing. The task is to find the repeating and missing numbers A and B where A repeats twice and B is missing.give code","Code in Java:


import java.util.*;

public class Main {

    public static int[] findMissingRepeatingNumbers(int[] a) {
        int n = a.length; // size of the array
        int xr = 0;

        //Step 1: Find XOR of all elements:
        for (int i = 0; i < n; i++) {
            xr = xr ^ a[i];
            xr = xr ^ (i + 1);
        }

        //Step 2: Find the differentiating bit number:
        int number = (xr & ~(xr - 1));

        //Step 3: Group the numbers:
        int zero = 0;
        int one = 0;
        for (int i = 0; i < n; i++) {
            //part of 1 group:
            if ((a[i] & number) != 0) {
                one = one ^ a[i];
            }
            //part of 0 group:
            else {
                zero = zero ^ a[i];
            }
        }

        for (int i = 1; i <= n; i++) {
            //part of 1 group:
            if ((i & number) != 0) {
                one = one ^ i;
            }
            //part of 0 group:
            else {
                zero = zero ^ i;
            }
        }

        // Last step: Identify the numbers:
        int cnt = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] == zero) cnt++;
        }

        if (cnt == 2) return new int[] {zero, one};
        return new int[] {one, zero};
    }


    public static void main(String[] args) {
        int[] a = {3, 1, 2, 5, 4, 6, 7, 5};
        int[] ans = findMissingRepeatingNumbers(a);
        System.out.println(""The repeating and missing numbers are: {""
                           + ans[0] + "", "" + ans[1] + ""}"");
    }
}

Time Complexity: O(N), where N = the size of the given array.
Reason: We are just using some loops running for N times. So, the time complexity will be approximately O(N).

Space Complexity: O(1) as we are not using any extra space to solve this problem"
"Count inversions in an array. Given an array of N integers, count the inversion of the array (using merge-sort).","Code in java:
import java.util.*;

public class Main {

    private static int merge(int[] arr, int low, int mid, int high) {
        ArrayList<Integer> temp = new ArrayList<>(); // temporary array
        int left = low;      // starting index of left half of arr
        int right = mid + 1;   // starting index of right half of arr

        //Modification 1: cnt variable to count the pairs:
        int cnt = 0;

        //storing elements in the temporary array in a sorted manner//

        while (left <= mid && right <= high) {
            if (arr[left] <= arr[right]) {
                temp.add(arr[left]);
                left++;
            } else {
                temp.add(arr[right]);
                cnt += (mid - left + 1); //Modification 2
                right++;
            }
        }

        // if elements on the left half are still left //

        while (left <= mid) {
            temp.add(arr[left]);
            left++;
        }

        //  if elements on the right half are still left //
        while (right <= high) {
            temp.add(arr[right]);
            right++;
        }

        // transfering all elements from temporary to arr //
        for (int i = low; i <= high; i++) {
            arr[i] = temp.get(i - low);
        }
        return cnt; // Modification 3
    }

    public static int mergeSort(int[] arr, int low, int high) {
        int cnt = 0;
        if (low >= high) return cnt;
        int mid = (low + high) / 2 ;
        cnt += mergeSort(arr, low, mid);  // left half
        cnt += mergeSort(arr, mid + 1, high); // right half
        cnt += merge(arr, low, mid, high);  // merging sorted halves
        return cnt;
    }

    public static int numberOfInversions(int[] a, int n) {
        // Count the number of pairs:
        return mergeSort(a, 0, n - 1);
    }


    public static void main(String[] args) {
        int[] a = {5, 4, 3, 2, 1};
        int n = 5;
        int cnt = numberOfInversions(a, n);
        System.out.println(""The number of inversions are: "" + cnt);
    }
}

Time Complexity: O(N*logN), where N = size of the given array.
Reason: We are not changing the merge sort algorithm except by adding a variable to it. So, the time complexity is as same as the merge sort.

Space Complexity: O(N), as in the merge sort We use a temporary array to store elements in sorted order."
code for two sum problem,"Code in Java:import java.util.*;

public class Main {
    public static String twoSum(int n, int []arr, int target) {
        Arrays.sort(arr);
        int left = 0, right = n - 1;
        while (left < right) {
            int sum = arr[left] + arr[right];
            if (sum == target) {
                return ""YES"";
            } else if (sum < target) left++;
            else right--;
        }
        return ""NO"";
    }

    public static void main(String args[]) {
        int n = 5;
        int[] arr = {2, 6, 5, 8, 11};
        int target = 14;
        String ans = twoSum(n, arr, target);
        System.out.println(""This is the answer for variant 1: "" + ans);

    }}Time Complexity: O(N) + O(N*logN), where N = size of the array.
Reason: The loop will run at most N times. And sorting the array will take N*logN time complexity.

Space Complexity: O(1) as we are not using any extra space."
4 Sum | Find Quads that add up to a target value,"Code in Java:


import java.util.*;

public class Main {
    public static List<List<Integer>> fourSum(int[] nums, int target) {
        int n = nums.length; // size of the array
        List<List<Integer>> ans = new ArrayList<>();

        // sort the given array:
        Arrays.sort(nums);

        // calculating the quadruplets:
        for (int i = 0; i < n; i++) {
            // avoid the duplicates while moving i:
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < n; j++) {
                // avoid the duplicates while moving j:
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;

                // 2 pointers:
                int k = j + 1;
                int l = n - 1;
                while (k < l) {
                    long sum = nums[i];
                    sum += nums[j];
                    sum += nums[k];
                    sum += nums[l];
                    if (sum == target) {
                        List<Integer> temp = new ArrayList<>();
                        temp.add(nums[i]);
                        temp.add(nums[j]);
                        temp.add(nums[k]);
                        temp.add(nums[l]);
                        ans.add(temp);
                        k++;
                        l--;

                        // skip the duplicates:
                        while (k < l && nums[k] == nums[k - 1]) k++;
                        while (k < l && nums[l] == nums[l + 1]) l--;
                    } else if (sum < target) k++;
                    else l--;
                }
            }
        }

        return ans;
    }

    public static void main(String[] args) {
        int[] nums = {4, 3, 3, 4, 4, 2, 1, 2, 1, 1};
        int target = 9;
        List<List<Integer>> ans = fourSum(nums, target);
        System.out.println(""The quadruplets are: "");
        for (List<Integer> it : ans) {
            System.out.print(""["");
            for (int ele : it) {
                System.out.print(ele + "" "");
            }
            System.out.print(""] "");
        }
        System.out.println();
    }
}

Time Complexity: O(N3), where N = size of the array.
Reason: Each of the pointers i and j, is running for approximately N times. And both the pointers k and l combined can run for approximately N times including the operation of skipping duplicates. So the total time complexity will be O(N3). 

Space Complexity: O(no. of quadruplets), This space is only used to store the answer. We are not using any extra space to solve this problem. So, from that perspective, space complexity can be written as O(1).

"
Longest Consecutive Sequence in an Array,"Code in Java:


import java.util.*;

public class Main {
    public static int longestSuccessiveElements(int[] a) {
        int n = a.length;
        if (n == 0)
            return 0;

        int longest = 1;
        Set<Integer> set = new HashSet<>();

        // put all the array elements into set
        for (int i = 0; i < n; i++) {
            set.add(a[i]);
        }

        // Find the longest sequence
        for (int it : set) {
            // if 'it' is a starting number
            if (!set.contains(it - 1)) {
                // find consecutive numbers
                int cnt = 1;
                int x = it;
                while (set.contains(x + 1)) {
                    x = x + 1;
                    cnt = cnt + 1;
                }
                longest = Math.max(longest, cnt);
            }
        }
        return longest;
    }

    public static void main(String[] args) {
        int[] a = {100, 200, 1, 2, 3, 4};
        int ans = longestSuccessiveElements(a);
        System.out.println(""The longest consecutive sequence is "" + ans);
    }
}

Time Complexity: O(N) + O(2*N) ~ O(3*N), where N = size of the array.
Reason: O(N) for putting all the elements into the set data structure. After that for every starting element, we are finding the consecutive elements. Though we are using nested loops, the set will be traversed at most twice in the worst case. So, the time complexity is O(2*N) instead of O(N2).

Space Complexity: O(N), as we are using the set data structure to solve this problem.
"
Length of the longest subarray with zero Sum,"Code in Java:


int maxLen(int A[], int n)
    {
        // Your code here
        HashMap<Integer, Integer> mpp = new HashMap<Integer, Integer>();

        int maxi = 0;
        int sum = 0; 

        for(int i = 0;i<n;i++) {

            sum += A[i]; 

            if(sum == 0) {
                maxi = i + 1; 
            }
            else {
                if(mpp.get(sum) != null) {

                    maxi = Math.max(maxi, i - mpp.get(sum)); 
                }
                else {

                    mpp.put(sum, i); 
                }
            }
        }
        return maxi; 
    }

Time Complexity: O(N), as we are traversing the array only once

Space Complexity: O(N), in the worst case we would insert all array elements prefix sum into our hashmap"
Count the number of subarrays with given xor K,"Code in Java:


import java.util.*;

public class Main{

    public static int subarraysWithXorK(int []a, int k) {
        int n = a.length; //size of the given array.
        int xr = 0;
        Map<Integer, Integer> mpp = new HashMap<>(); //declaring the map.
        mpp.put(xr, 1); //setting the value of 0.
        int cnt = 0;

        for (int i = 0; i < n; i++) {
            // prefix XOR till index i:
            xr = xr ^ a[i];

            //By formula: x = xr^k:
            int x = xr ^ k;

            // add the occurrence of xr^k
            // to the count:
            if (mpp.containsKey(x)) {
                cnt += mpp.get(x);
            }

            // Insert the prefix xor till index i
            // into the map:
            if (mpp.containsKey(xr)) {
                mpp.put(xr, mpp.get(xr) + 1);
            } else {
                mpp.put(xr, 1);
            }
        }
        return cnt;
    }

    public static void main(String[] args) {
        int[] a = {4, 2, 2, 6, 4};
        int k = 6;
        int ans = subarraysWithXorK(a, k);
        System.out.println(""The number of subarrays with XOR k is: "" + ans);
    }
}

Time Complexity: O(N) or O(N*logN) depending on which map data structure we are using, where N = size of the array.Space Complexity: O(N) as we are using a map data structure.
"
Length of Longest Substring without any Repeating Character,"Code in Java:import java.util.*;
public class Main {
    static int solve(String s) {
        HashMap < Character, Integer > mpp = new HashMap < Character, Integer > ();

        int left = 0, right = 0;
        int n = s.length();
        int len = 0;
        while (right < n) {
            if (mpp.containsKey(s.charAt(right))) left = Math.max(mpp.get(s.charAt(right)) + 1, left);

            mpp.put(s.charAt(right), right);

            len = Math.max(len, right - left + 1);
            right++;
        }
        return len;
    }

    public static void main(String args[]) {
        String str = ""takeUforward"";
        System.out.println(""The length of the longest substring without repeating 
        characters is "" + solve(str));

    }
}Time Complexity: O( N )

Space Complexity: O(N) where N represents the size of HashSet where we are storing our elements"
Find intersection of Two Linked Lists,"Code in Java:import java.util.*;
class Node {
        int num;
        Node next;
        Node(int val) {
            num = val;
            next = null;
        }
}
class Main{
//utility function to insert node at the end of the linked list
static Node insertNode(Node head,int val) {
    Node newNode = new Node(val);
    
    if(head == null) {
        head = newNode;
        return head;
    }
    
    Node temp = head;
    while(temp.next != null) temp = temp.next;
    
    temp.next = newNode;
    return head;
}
//utility function to check presence of intersection
static Node intersectionPresent(Node head1,Node head2) {
    Node d1 = head1;
    Node d2 = head2;
    
    while(d1 != d2) {
        d1 = d1 == null? head2:d1.next;
        d2 = d2 == null? head1:d2.next;
    }
    
    return d1;
}

//utility function to print linked list created
static void printList(Node head) {
    while(head.next != null) {
    System.out.print(head.num+""->"");
        head = head.next;
    }
    System.out.println(head.num);
}

public static void main(String args[]) {
    // creation of both lists 
    Node head = null;
    head=insertNode(head,1);
    head=insertNode(head,3);
    head=insertNode(head,1);
    head=insertNode(head,2);
    head=insertNode(head,4);
    Node head1 = head;
    head = head.next.next.next;
    Node headSec = null;
    headSec=insertNode(headSec,3);
    Node head2 = headSec;
    headSec.next = head;
    //printing of the lists
    System.out.print(""List1: ""); printList(head1);
    System.out.print(""List2: ""); printList(head2);
    //checking if intersection is present
    Node answerNode = intersectionPresent(head1,head2);
    if(answerNode == null)  
    System.out.println(""No intersection\n"");
    else
    System.out.println(""The intersection point is ""+answerNode.num);
    
}
}Time Complexity: O(2*max(length of list1,length of list2))

Reason: Uses the same concept of the difference of lengths of two lists.

Space Complexity: O(1)"
Detect a Cycle in a Linked List,"Code in Java:
import java.util.HashMap;
import java.util.Map;

// Node class represents a
// node in a linked list
class Node {
    // Data stored in the node
    public int data;   
    // Pointer to the next node in the list
    public Node next;  

    // Constructor with both data
    // and next node as parameters
    public Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }

    // Constructor with only data as
    // a parameter, sets next to null
    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class Main {

    // Function to detect a loop in a linked list
    // using the Tortoise and Hare Algorithm
    public static boolean detectCycle(Node head) {
        // Initialize two pointers, slow and fast,
        // to the head of the linked list
        Node slow = head;
        Node fast = head;

        // Step 2: Traverse the linked list
        // with the slow and fast pointers
        while (fast != null && fast.next != null) {
            // Move slow one step
            slow = slow.next;
            // Move fast two steps
            fast = fast.next.next;

            // Check if slow and fast pointers meet
            if (slow == fast) {
                return true;  // Loop detected
            }
        }

        // If fast reaches the end of the
        // list, there is no loop
        return false;
    }


    public static void main(String[] args) {
        // Create a sample linked list
        // with a loop for testing
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);
        Node fourth = new Node(4);
        Node fifth = new Node(5);

        head.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        // Create a loop
        fifth.next = third;

        // Check if there is a loop
        // in the linked list
        if (detectCycle(head)) {
            System.out.println(""Loop detected in the linked list."");
        } else {
            System.out.println(""No loop detected in the linked list."");
        }

        // No need to explicitly free memory
        // in Java; the garbage collector handles it
    }
}
Time Complexity: O(N), Space Complexity : O(1)
"
Reverse Linked List in groups of Size K,"Code in Java:import java.util.*;

// Node class represents a
// node in a linked list
class Node {
    // Data stored in the node
    int data;      
    // Pointer to the next
    // node in the list
    Node next;     

    // Constructor with both data
    // and next node as parameters
    Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }

    // Constructor with only data as
    // a parameter, sets next to null
    Node(int data) {
        this.data = data;
        this.next = null;
    }
}
public class Main {

    // Function to reverse a linked list
    // using the 3-pointer approach
    static Node reverseLinkedList(Node head) {
        // Initialize'temp' at
        // head of linked list
        Node temp = head;  
   
       // Initialize pointer 'prev' to NULL,
       // representing the previous node
       Node prev = null;  
       
       // Traverse the list, continue till
       // 'temp' reaches the end (NULL)
       while(temp != null){  
           // Store the next node in
           // 'front' to preserve the reference
           Node front = temp.next;  
           
           // Reverse the direction of the
           // current node's 'next' pointer
           // to point to 'prev'
           temp.next = prev;  
           
            // Move 'prev' to the current
            // node for the next iteration
           prev = temp;  
           
            // Move 'temp' to the 'front' node
            // advancing the traversal
           temp = front; 
       }
       
       // Return the new head of
       // the reversed linked list
       return prev;  

    }

    // Function to get the Kth node from
    // a given position in the linked list
    static Node getKthNode(Node temp, int k) {
        // Decrement K as we already
        // start from the 1st node
        k -= 1;
        
        // Decrement K until it reaches
        // the desired position
        while (temp != null && k > 0) {
            // Decrement k as temp progresses
            k--;
            
            // Move to the next node
            temp = temp.next;
        }
        
        // Return the Kth node
        return temp;
    }

    // Function to reverse nodes in groups of K
    static Node kReverse(Node head, int k) {
        // Initialize a temporary
        // node to traverse the list
        Node temp = head;
        
        // Initialize a pointer to track the
        // last node of the previous group
        Node prevLast = null;
        
        // Traverse through the linked list
        while (temp != null) {
            
            // Get the Kth node of the current group
            Node kThNode = getKthNode(temp, k);
            
            // If the Kth node is NULL
            // (not a complete group)
            if (kThNode == null) {
               
                // If there was a previous group,
                // link the last node to the current node
                if (prevLast != null) {
                    prevLast.next = temp;
                }
                
                // Exit the loop
                break;
            }
            
            // Store the next node
            // after the Kth node
            Node nextNode = kThNode.next;
            
            // Disconnect the Kth node
            // to prepare for reversal
            kThNode.next = null;
            
            // Reverse the nodes from
            // temp to the Kth node
            reverseLinkedList(temp);
            
             // Adjust the head if the reversal
            // starts from the head
            if (temp == head) {
                head = kThNode;
            } else {
                // Link the last node of the previous
                // group to the reversed group
                prevLast.next = kThNode;
            }
            
            // Update the pointer to the
            // last node of the previous group
            prevLast = temp;
            
            // Move to the next group
            temp = nextNode;
        }
        
        // Return the head of the
        // modified linked list
        return head;
    }

    // Function to print the linked list
    static void printLinkedList(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + "" "");
            temp = temp.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create a linked list with
        // values 5, 4, 3, 7, 9 and 2
        Node head = new Node(5);
        head.next = new Node(4);
        head.next.next = new Node(3);
        head.next.next.next = new Node(7);
        head.next.next.next.next = new Node(9);
        head.next.next.next.next.next = new Node(2);

        // Print the original linked list
        System.out.print(""Original Linked List: "");
        printLinkedList(head);

        // Reverse the linked list
        head = kReverse(head, 4);

        // Print the reversed linked list
        System.out.print(""Reversed Linked List: "");
        printLinkedList(head);
    }
}Time Complexity: O(2N)Space Complexity: O(1)"
Check if the given Linked List is Palindrome,"Code in Java:
import java.util.Stack;

// Node class represents a
// node in a linked list
class Node {
    // Data stored in the node
    int data;      
    // Pointer to the next
    // node in the list
    Node next;     

    // Constructor with both data
    // and next node as parameters
    Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }

    // Constructor with only data as
    // a parameter, sets next to null
    Node(int data) {
        this.data = data;
        this.next = null;
    }
}
    // Function to reverse a linked list
    // using the recursive approach
    public Node reverseLinkedList(Node head) {
        // Check if the list is empty or has only one node
        if (head == null || head.next == null) {

            // No change is needed;
            // return the current head
            return head;
        }

        // Recursive step: Reverse the remaining
        // part of the list and get the new head
        Node newHead = reverseLinkedList(head.next);

        // Store the next node in 'front'
        // to reverse the link
        Node front = head.next;

        // Update the 'next' pointer of 'front' to
        // point to the current head, effectively
        // reversing the link direction
        front.next = head;

        // Set the 'next' pointer of the
        // current head to 'null' to
        // break the original link
        head.next = null;

        // Return the new head obtained
        // from the recursion
        return newHead;
    }
    
    public static boolean isPalindrome(Node head) {
        // Check if the linked list is
        // empty or has only one node
        if (head == null || head.next == null) {
            // It's a palindrome by definition
            return true;
        }
    
        // Initialize two pointers, slow and fast,
        // to find the middle of the linked list
        Node slow = head;
        Node fast = head;
    
        // Traverse the linked list to find the
        // middle using slow and fast pointers
        while (fast.next != null && fast.next.next != null) {
            // Move slow pointer one step at a time
            slow = slow.next;
    
            // Move fast pointer two steps at a time
            fast = fast.next.next;
        }
    
        // Reverse the second half of the 
        // linked list starting from the middle
        Node newHead = reverseLinkedList(slow.next);
    
        // Pointer to the first half
        Node first = head;
    
        // Pointer to the reversed second half
        Node second = newHead;
        while (second != null) {
            // Compare data values of
            // nodes from both halves
    
            // If values do not match, the
            // list is not a palindrome
            if (first.data != second.data) {
                
                // Reverse the second half back
                // to its original state
                reverseLinkedList(newHead);
    
                // Not a palindrome
                return false;
            }
    
            // Move the first pointer
            first = first.next;
    
            // Move the second pointer
            second = second.next;
        }
    
        // Reverse the second half back
        // to its original state
        reverseLinkedList(newHead);
    
        // The linked list is a palindrome
        return true;
    }   


    // Function to print the linked list
    public static void printLinkedList(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + "" "");
            temp = temp.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create a linked list with
        // values 1, 5, 2, 5, and 1 (15251, a palindrome)
        Node head = new Node(1);
        head.next = new Node(5);
        head.next.next = new Node(2);
        head.next.next.next = new Node(5);
        head.next.next.next.next = new Node(1);

        // Print the original linked list
        System.out.print(""Original Linked List: "");
        printLinkedList(head);

        // Check if the linked list is a palindrome
        if (isPalindrome(head)) {
            System.out.println(""The linked list is a palindrome."");
        } else {
            System.out.println(""The linked list is not a palindrome."");
        }
    }

}

Time Complexity: O (2* N) Space Complexity: O(1)"
Starting point of loop in a Linked List,"Code in Java:
                                
import java.util.HashMap;

// Node class represents a
// node in a linked list
class Node {
    // Data stored in the node
    int data;        
    // Pointer to the next node in the list
    Node next;      

    // Constructor with both data
    // and next node as parameters
    Node(int data1, Node next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data as
    // a parameter, sets next to null
    Node(int data1) {
        data = data1;
        next = null;
    }
}

public class LinkedListLoopDetection {
    // Function to find the first node
    // of the loop in a linked list

    public static Node firstNode(Node head) {
        // Initialize a slow and fast 
        // pointers to the head of the list
        Node slow = head;  
        Node fast = head;  
    
        // Phase 1: Detect the loop
        while (fast != null && fast.next != null) {
            // Move slow one step
            slow = slow.next;        
            
            // Move fast two steps
            fast = fast.next.next;  
    
            // If slow and fast meet,
            // a loop is detected
            if (slow == fast) {
                // Reset the slow pointer
                // to the head of the list
                slow = head; 
    
                // Phase 2: Find the first node of the loop
                while (slow != fast) {
                    // Move slow and fast one step
                    // at a time
                    slow = slow.next;  
                    fast = fast.next;  
    
                    // When slow and fast meet again,
                    // it's the first node of the loop
                }
                
                // Return the first node of the loop
                return slow;  
            }
        }
        
        // If no loop is found, return null
        return null; 
    }

    public static void main(String[] args) {
        // Create a sample linked list with a loop
        Node node1 = new Node(1);
        Node node2 = new Node(2);
        node1.next = node2;
        Node node3 = new Node(3);
        node2.next = node3;
        Node node4 = new Node(4);
        node3.next = node4;
        Node node5 = new Node(5);
        node4.next = node5;

        // Make a loop from node5 to node2
        node5.next = node2;

        // Set the head of the linked list
        Node head = node1;

        // Detect the loop in the linked list
        Node loopStartNode = firstNode(head);

        if (loopStartNode != null) {
            System.out.println(""Loop detected. Starting node of the loop is: "" + loopStartNode.data);
        } else {
            System.out.println(""No loop detected in the linked list."");
        }
    }
}
                                
 Time Complexity: O(N) Space Complexity : O(1) "
Flattening a Linked List,"Code in Java:class Main
{
    Node mergeTwoLists(Node a, Node b) {
        
        Node temp = new Node(0);
        Node res = temp; 
        
        while(a != null && b != null) {
            if(a.data < b.data) {
                temp.bottom = a; 
                temp = temp.bottom; 
                a = a.bottom; 
            }
            else {
                temp.bottom = b;
                temp = temp.bottom; 
                b = b.bottom; 
            }
        }
        
        if(a != null) temp.bottom = a; 
        else temp.bottom = b;
        return res.bottom; 
    
    }
    Node flatten(Node root)
    {
       
            if (root == null || root.next == null) 
                return root; 
      
            // recur for list on right 
            root.next = flatten(root.next); 
      
            // now merge 
            root = mergeTwoLists(root, root.next); 
      
            // return the root 
            // it will be in turn merged with its left 
            return root; 
    }
}Time Complexity: O(N), where N is the total number of nodes present

Reason: We are visiting all the nodes present in the given list.

Space Complexity: O(1)

Reason: We are not creating new nodes or using any other data structure.

"
What is DSA?,"DSA stands for Data Structures and Algorithms, which are the building blocks of computer programs. DSA deals with organizing and managing data efficiently to optimize the performance of algorithms used to solve problems."
What is the difference between a linear data structure and a non-linear data structure?,"A linear data structure has elements arranged sequentially, whereas a non-linear data structure has elements arranged in a hierarchical or nonlinear manner."
What are the basic operations performed on data structures?,"The basic operations performed on data structures include insertion, deletion, traversal, search, and sorting."
What is the time complexity of an algorithm?,The time complexity of an algorithm is the measure of the amount of time it takes to run as a function of the input size.
What is the space complexity of an algorithm?,The space complexity of an algorithm is the measure of the amount of memory it takes to run as a function of the input size.
What is Big O notation?,"Big O notation is used to describe the upper bound of the time complexity of an algorithm. It describes the worst-case scenario for an algorithm in terms of the input size.
"
What is the difference between time and space complexity?,"Time complexity is a measure of the amount of time an algorithm takes to run as a function of the input size, whereas space complexity is a measure of the amount of memory an algorithm uses as a function of the input size."
What is a binary tree?,"A binary tree is a tree where each node has at most two child nodes, known as the left child and the right child."
What is a binary search tree?,"A binary search tree is a binary tree where the value of each node is greater than or equal to the value of its left child, and less than or equal to the value of its right child. This property allows for efficient searching, insertion, and deletion operations."
What is a trie?,"A trie is a tree-like data structure used for efficient retrieval of keys from a set of strings. Each node in the trie represents a prefix of one or more strings, and the children of a node represent the possible next characters in those strings."
What is a heap?,"A heap is a binary tree that satisfies the heap property, which is that the value of each node is greater than or equal to (for a max heap) or less than or equal to (for a min heap) the values of its children. Heaps are used for efficient implementation of priority queues."
What is a directed graph?,"A directed graph is a graph where the edges have a direction, meaning they go from one vertex (the source) to another vertex (the destination)."
What is an undirected graph?,"An undirected graph is a graph where the edges do not have a direction, meaning they connect two vertices in both directions."
What is a depth-first search (DFS)? ,"Depth-first search (DFS) is a graph traversal algorithm that starts at a given vertex and explores as far as possible along each branch before backtracking. This algorithm can be used to search for connected components, cycle detection, and topological sorting."
What is a breadth-first search?,"Breadth-first search (BFS) is a graph traversal algorithm that visits all the vertices of a graph in breadth-first order, i.e., it visits all the vertices at distance 1 from the source vertex, then all the vertices at distance 2, and so on."
What is Dijkstra's algorithm?,Dijkstra's algorithm is a shortest path algorithm that finds the shortest path between a source vertex and all other vertices in a weighted graph with non-negative edge weights. It uses a priority queue to greedily select the closest vertex to the source and updates the distances of its neighbors accordingly.
What is Bellman-Ford algorithm?,"Bellman-Ford algorithm is a shortest path algorithm that finds the shortest path between a source vertex and all other vertices in a weighted graph, even when the edge weights are negative. It works by relaxing all the edges repeatedly and detecting negative weight cycles."
What is Floyd-Warshall algorithm?,"Floyd-Warshall algorithm is an all-pairs shortest path algorithm that finds the shortest path between every pair of vertices in a weighted graph, even with negative edge weights. It works by using dynamic programming to iteratively compute the shortest path matrix."
What is Kruskal's algorithm?,"Kruskal's algorithm is a greedy algorithm that finds the minimum spanning tree of a connected, undirected graph. It works by repeatedly adding the smallest edge that does not create a cycle until all vertices are connected."
What is Prim's algorithm?,"Prim's algorithm is a greedy algorithm that finds the minimum spanning tree of a connected, undirected graph. It works by starting with an arbitrary vertex and adding the smallest edge that connects to an unvisited vertex until all vertices are connected."
What is an AVL tree?,An AVL tree is a self-balancing binary search tree where the heights of the left and right subtrees of any node differ by at most one. This ensures that the worst-case time complexity of operations on the tree is O(log n).
What is a red-black tree?,"A red-black tree is a self-balancing binary search tree where each node is colored red or black, and the tree satisfies the red-black tree properties, which ensure that the tree is balanced. This ensures that the worst-case time complexity of operations on the tree is O(log n)."
What is dynamic programming?,Dynamic programming is an algorithmic technique that solves complex problems by breaking them down into smaller subproblems and storing the solutions to these subproblems to avoid redundant computations. It is particularly useful for problems with overlapping subproblems and optimal substructure.
What is memoization?,Memoization is a technique used in dynamic programming where the results of expensive function calls are stored and reused when the same inputs occur again.
What is a dynamic programming table?,A dynamic programming table is a two-dimensional array used in dynamic programming to store the solutions to subproblems. Each cell in the table represents the solution to a particular subproblem and is calculated using the solutions to other subproblems.
What is the longest common subsequence problem?,The longest common subsequence problem is a classic problem in dynamic programming that involves finding the longest subsequence that is common to two or more sequences. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.
Program / code for longest common subsequence problem,"When given two strings, S1, and S2 (suppose of same length n), the simplest approach will be to generate all the subsequences and store them, then manually find out the longest common subsequence.

This naive approach will give us the correct answer but to generate all the subsequences, we will require exponential ( 2n ) time. Hence we can try dynamic programming approach.
Using Dynamic programming : 
->Memoization approach:
-Create a dp array of size [N][M] where N and M are lengths of S1 and S2 respectively. It will store all the possible different states that our recursive function will take.
-We initialize the dp array to -1.
-Whenever we want to find the answer of particular parameters (say f(ind1,ind2)), we first check whether the answer is already calculated using the dp array(i.e dp[ind][ind2]!= -1 ). If yes, simply return the value from the dp array.
-If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[ind][ind2] to the solution we get.
Code in Java : 

import java.util.*;

class solution {
    // Recursive function to find the length of the Longest Common Subsequence (LCS)
    static int lcsUtil(String s1, String s2, int ind1, int ind2, int[][] dp) {
        // Base case: If either of the strings reaches the end, return 0
        if (ind1 < 0 || ind2 < 0)
            return 0;

        // If the result for this subproblem has already been calculated, return it
        if (dp[ind1][ind2] != -1)
            return dp[ind1][ind2];

        // If the characters at the current indices are the same, increment the LCS length
        if (s1.charAt(ind1) == s2.charAt(ind2))
            return dp[ind1][ind2] = 1 + lcsUtil(s1, s2, ind1 - 1, ind2 - 1, dp);

        // If the characters are different, choose the maximum LCS length by either
        // skipping a character in s1 or skipping a character in s2
        else
            return dp[ind1][ind2] = Math.max(lcsUtil(s1, s2, ind1, ind2 - 1, dp),
                    lcsUtil(s1, s2, ind1 - 1, ind2, dp));
    }

    // Function to find the length of the Longest Common Subsequence (LCS)
    static int lcs(String s1, String s2) {
        int n = s1.length();
        int m = s2.length();

        // Create a 2D array to store results of subproblems
        int dp[][] = new int[n][m];

        // Initialize the dp array with -1 to indicate that subproblems are not solved yet
        for (int rows[] : dp)
            Arrays.fill(rows, -1);

        // Call the recursive function to find the LCS length
        return lcsUtil(s1, s2, n - 1, m - 1, dp);
    }

    public static void main(String args[]) {
        String s1 = ""acd"";
        String s2 = ""ced"";

        // Call the lcs function and print the result
        System.out.println(""The Length of Longest Common Subsequence is "" + lcs(s1, s2));
    }
}

Time Complexity: O(N*M)

Reason: There are N*M states therefore at max ‘N*M’ new problems will be solved.

Space Complexity: O(N*M) + O(N+M)

Reason: We are using an auxiliary recursion stack space(O(N+M)) (see the recursive tree, in the worst case, we will go till N+M calls at a time) and a 2D array ( O(N*M)).

Tabulation approach : 
To convert the memoization approach to a tabulation one, create a dp array with the same size as done in memoization. 
Code in Java : 

import java.util.*;

class solution {
    // Function to find the length of the Longest Common Subsequence (LCS)
    static int lcs(String s1, String s2) {
        int n = s1.length();
        int m = s2.length();

        // Create a 2D array to store results of subproblems
        int dp[][] = new int[n + 1][m + 1];

        // Initialize the dp array with -1 to indicate that subproblems are not solved yet
        for (int rows[] : dp)
            Arrays.fill(rows, -1);

        // Initialize the first row and first column with zeros since LCS with an empty string is zero
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 0;
        }
        for (int i = 0; i <= m; i++) {
            dp[0][i] = 0;
        }

        // Fill the dp array using dynamic programming
        for (int ind1 = 1; ind1 <= n; ind1++) {
            for (int ind2 = 1; ind2 <= m; ind2++) {
                // If the characters at the current indices are the same, increment the LCS length
                if (s1.charAt(ind1 - 1) == s2.charAt(ind2 - 1))
                    dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1];
                // If the characters are different, choose the maximum LCS length by either
                // excluding a character in s1 or excluding a character in s2
                else
                    dp[ind1][ind2] = Math.max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]);
            }
        }

        return dp[n][m]; // Return the length of the Longest Common Subsequence (LCS)
    }

    public static void main(String args[]) {
        String s1 = ""acd"";
        String s2 = ""ced"";

        // Call the lcs function and print the result
        System.out.println(""The Length of Longest Common Subsequence is "" + lcs(s1, s2));
    }
}

Complexity analysis : 
Time Complexity: O(N*M)

Reason: There are two nested loops

Space Complexity: O(N*M)

Reason: We are using an external array of size ‘N*M)’. Stack Space is eliminated."
What is the knapsack problem?,"The knapsack problem is a classic problem in combinatorial optimization that involves finding the optimal set of items to pack into a knapsack with limited capacity. Each item has a weight and a value, and the goal is to maximize the total value of the items packed into the knapsack while not exceeding its capacity."
Program / Code for Knapsack problem,"Memoization Approach for 0/1 Knapsack Problem: 
Top-Down Approach
Code in Java : 
import java.io.*;

class solution {

    // A utility function that returns
    // maximum of two integers
    static int max(int a, int b) { return (a > b) ? a : b; }

    // Returns the value of maximum profit
    static int knapSackRec(int W, int wt[], int val[],
                           int n, int[][] dp)
    {

        // Base condition
        if (n == 0 || W == 0)
            return 0;

        if (dp[n][W] != -1)
            return dp[n][W];

        if (wt[n - 1] > W)

            // Store the value of function call
            // stack in table before return
            return dp[n][W]
                = knapSackRec(W, wt, val, n - 1, dp);

        else

            // Return value of table after storing
            return dp[n][W]
                = max((val[n - 1]
                       + knapSackRec(W - wt[n - 1], wt, val,
                                     n - 1, dp)),
                      knapSackRec(W, wt, val, n - 1, dp));
    }

    static int knapSack(int W, int wt[], int val[], int N)
    {

        // Declare the table dynamically
        int dp[][] = new int[N + 1][W + 1];

        // Loop to initially filled the
        // table with -1
        for (int i = 0; i < N + 1; i++)
            for (int j = 0; j < W + 1; j++)
                dp[i][j] = -1;

        return knapSackRec(W, wt, val, N, dp);
    }

    // Driver Code
    public static void main(String[] args)
    {
        int profit[] = { 60, 100, 120 };
        int weight[] = { 10, 20, 30 };

        int W = 50;
        int N = profit.length;

        System.out.println(knapSack(W, weight, profit, N));
    }
}
Time Complexity: O(N * W). As redundant calculations of states are avoided.
Space Complexity: O(N * W) + O(N). The use of a 2D array data structure for storing intermediate states and O(N) auxiliary stack space(ASS) has been used for recursion stack
"
Program / Code for implementation of fractional knapsack problem,"Approach : The greedy method to maximize our answer will be to pick up the items with higher values. Since it is possible to break the items as well we should focus on picking up items having higher value /weight first. To achieve this, items should be sorted in decreasing order with respect to their value /weight. Once the items are sorted we can iterate. Pick up items with weight lesser than or equal to the current capacity of the knapsack. In the end, if the weight of an item becomes more than what we can carry, break the item into smaller units. Calculate its value according to our current capacity and add this new value to our answer.

Code in Java : 
import java.util.*;
class Item {
  int value, weight;
  Item(int x, int y) {
    this.value = x;
    this.weight = y;
  }
}

class itemComparator implements Comparator<Item>
{
    @Override
    public int compare(Item a, Item b) 
    {
        double r1 = (double)(a.value) / (double)(a.weight); 
        double r2 = (double)(b.value) / (double)(b.weight); 
        if(r1 < r2) return 1; 
        else if(r1 > r2) return -1; 
        else return 0; 
    }
}
public class solve{
    static double fractionalKnapsack(int W, Item arr[], int n) {
        Arrays.sort(arr, new itemComparator()); 
        
        int curWeight = 0; 
        double finalvalue = 0.0; 
        
        for (int i = 0; i < n; i++) {
       
            if (curWeight + arr[i].weight <= W) {
                curWeight += arr[i].weight;
                finalvalue += arr[i].value;
            }
     
            else {
                int remain = W - curWeight;
                finalvalue += ((double)arr[i].value / (double)arr[i].weight) * (double)remain;
                break;
            }
        }
     
        return finalvalue;
        
    }
    public static void main(String args[])
    {
        int n = 3, weight = 50;
        Item arr[] = {new Item (100,20),new Item(60,10),new Item(120,30)};
        double ans = fractionalKnapsack(weight, arr, n);
        System.out.println(""The maximum value is ""+ans);
    }
}
Complexity analysis : 
Time Complexity: O(n log n + n). O(n log n) to sort the items and O(n) to iterate through all the items for calculating the answer.

Space Complexity: O(1), no additional data structure has been used."
What is the traveling salesman problem?,The traveling salesman problem is a classic problem in combinatorial optimization that involves finding the shortest possible route that visits a set of cities exactly once and returns to the starting city. It is a well-known NP-hard problem.
Program / Code for Implementation of Travelling salesman problem,"Approach :  Using Dynamic programmming 
Code in Java : 
import java.io.*;
import java.util.*;

public class TSE {
	// there are four nodes in example graph (graph is
	// 1-based)

	static int n = 4;
	// give appropriate maximum to avoid overflow

	static int MAX = 1000000;

	// dist[i][j] represents shortest distance to go from i
	// to j this matrix can be calculated for any given
	// graph using all-pair shortest path algorithms
	static int[][] dist = {
		{ 0, 0, 0, 0, 0 }, { 0, 0, 10, 15, 20 },
		{ 0, 10, 0, 25, 25 }, { 0, 15, 25, 0, 30 },
		{ 0, 20, 25, 30, 0 },
	};

	// memoization for top down recursion

	static int[][] memo = new int[n + 1][1 << (n + 1)];

	static int fun(int i, int mask)
	{
		// base case
		// if only ith bit and 1st bit is set in our mask,
		// it implies we have visited all other nodes
		// already
		if (mask == ((1 << i) | 3))
			return dist[1][i];
		// memoization
		if (memo[i][mask] != 0)
			return memo[i][mask];

		int res = MAX; // result of this sub-problem

		// we have to travel all nodes j in mask and end the
		// path at ith node so for every node j in mask,
		// recursively calculate cost of travelling all
		// nodes in mask
		// except i and then travel back from node j to node
		// i taking the shortest path take the minimum of
		// all possible j nodes

		for (int j = 1; j <= n; j++)
			if ((mask & (1 << j)) != 0 && j != i && j != 1)
				res = Math.min(res,
							fun(j, mask & (~(1 << i)))
								+ dist[j][i]);
		return memo[i][mask] = res;
	}

	// Driver program to test above logic
	public static void main(String[] args)
	{
		int ans = MAX;
		for (int i = 1; i <= n; i++)
			// try to go from node 1 visiting all nodes in
			// between to i then return from i taking the
			// shortest route to 1
			ans = Math.min(ans, fun(i, (1 << (n + 1)) - 1)
									+ dist[i][1]);

		System.out.println(
			""The cost of most efficient tour = "" + ans);
	}
}

Complexity analysis : 

Time Complexity : O(n2*2n) where O(n* 2n) are maximum number of unique subproblems/states and O(n) for transition (through for loop as in code) in every states.

Auxiliary Space: O(n*2n), where n is number of Nodes/Cities here."
What is the quicksort algorithm?,"The quicksort algorithm is a sorting algorithm that uses the divide-and-conquer approach. It works by partitioning an array into two subarrays around a pivot element, and recursively sorting the subarrays. The average time complexity of quicksort is O(n log n)."
Program / Code for Implementation of Quick sort,"QuickSort is a sorting algorithm based on the Divide and Conquer algorithm that picks an element as a pivot and partitions the given array around the picked pivot by placing the pivot in its correct position in the sorted array.The key process in quickSort is a partition(). The target of partitions is to place the pivot (any element can be chosen to be a pivot) at its correct position in the sorted array and put all smaller elements to the left of the pivot, and all greater elements to the right of the pivot.

Partition is done recursively on each side of the pivot after the pivot is placed in its correct position and this finally sorts the array.
Code in Java : 
import java.io.*;

class solution {

    // A utility function to swap two elements
    static void swap(int[] arr, int i, int j)
    {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    // This function takes last element as pivot,
    // places the pivot element at its correct position
    // in sorted array, and places all smaller to left
    // of pivot and all greater elements to right of pivot
    static int partition(int[] arr, int low, int high)
    {
        // Choosing the pivot
        int pivot = arr[high];

        // Index of smaller element and indicates
        // the right position of pivot found so far
        int i = (low - 1);

        for (int j = low; j <= high - 1; j++) {

            // If current element is smaller than the pivot
            if (arr[j] < pivot) {

                // Increment index of smaller element
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return (i + 1);
    }

    // The main function that implements QuickSort
    // arr[] --> Array to be sorted,
    // low --> Starting index,
    // high --> Ending index
    static void quickSort(int[] arr, int low, int high)
    {
        if (low < high) {

            // pi is partitioning index, arr[p]
            // is now at right place
            int pi = partition(arr, low, high);

            // Separately sort elements before
            // partition and after partition
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }
    // To print sorted array
    public static void printArr(int[] arr)
    {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "" "");
        }
    }

    // Driver Code
    public static void main(String[] args)
    {
        int[] arr = { 10, 7, 8, 9, 1, 5 };
        int N = arr.length;

        // Function call
        quickSort(arr, 0, N - 1);
        System.out.println(""Sorted array:"");
        printArr(arr);
    }
}
Complexity analysis : 
Time Complexity:

Best Case: Ω (N log (N))
The best-case scenario for quicksort occur when the pivot chosen at the each step divides the array into roughly equal halves.
In this case, the algorithm will make balanced partitions, leading to efficient Sorting.
Average Case: θ ( N log (N))
Quicksort’s average-case performance is usually very good in practice, making it one of the fastest sorting Algorithm.
Worst Case: O(N2)
The worst-case Scenario for Quicksort occur when the pivot at each step consistently results in highly unbalanced partitions. When the array is already sorted and the pivot is always chosen as the smallest or largest element. To mitigate the worst-case Scenario, various techniques are used such as choosing a good pivot (e.g., median of three) and using Randomized algorithm (Randomized Quicksort ) to shuffle the element before sorting.
Space Complexity O(1), if we don’t consider the recursive stack space. If we consider the recursive stack space then, in the worst case quicksort could make O(N)."
What is the mergesort algorithm?,"The mergesort algorithm is a sorting algorithm that uses the divide-and-conquer approach. It works by dividing an array into two subarrays, sorting each subarray recursively, and then merging the two sorted subarrays into a single sorted array. The worst-case time complexity of mergesort is O(n log n)."
Program / Code for Implementation of Merge sort,"Merge sort is a sorting algorithm that follows the divide-and-conquer approach. It works by recursively dividing the input array into smaller subarrays and sorting those subarrays then merging them back together to obtain the sorted array.Merge sort works by the following steps : Divide: Divide the list or array recursively into two halves until it can no more be divided.
Conquer: Each subarray is sorted individually using the merge sort algorithm.
Merge: The sorted subarrays are merged back together in sorted order. The process continues until all elements from both subarrays have been merged.Code in Java : import java.io.*;

class MergeSort {

    // Merges two subarrays of arr[].
    // First subarray is arr[l..m]
    // Second subarray is arr[m+1..r]
    void merge(int arr[], int l, int m, int r)
    {
        // Find sizes of two subarrays to be merged
        int n1 = m - l + 1;
        int n2 = r - m;

        // Create temp arrays
        int L[] = new int[n1];
        int R[] = new int[n2];

        // Copy data to temp arrays
        for (int i = 0; i < n1; ++i)
            L[i] = arr[l + i];
        for (int j = 0; j < n2; ++j)
            R[j] = arr[m + 1 + j];

        // Merge the temp arrays

        // Initial indices of first and second subarrays
        int i = 0, j = 0;

        // Initial index of merged subarray array
        int k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            }
            else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        // Copy remaining elements of L[] if any
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        // Copy remaining elements of R[] if any
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Main function that sorts arr[l..r] using
    // merge()
    void sort(int arr[], int l, int r)
    {
        if (l < r) {

            // Find the middle point
            int m = l + (r - l) / 2;

            // Sort first and second halves
            sort(arr, l, m);
            sort(arr, m + 1, r);

            // Merge the sorted halves
            merge(arr, l, m, r);
        }
    }

    // A utility function to print array of size n
    static void printArray(int arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n; ++i)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }

    // Driver code
    public static void main(String args[])
    {
        int arr[] = { 12, 11, 13, 5, 6, 7 };

        System.out.println(""Given array is"");
        printArray(arr);

        MergeSort ob = new MergeSort();
        ob.sort(arr, 0, arr.length - 1);

        System.out.println(""\nSorted array is"");
        printArray(arr);
    }
}Complexity analysis : Time Complexity:

Best Case: O(n log n), When the array is already sorted or nearly sorted.
Average Case: O(n log n), When the array is randomly ordered.
Worst Case: O(n log n), When the array is sorted in reverse order.
Space Complexity: O(n), Additional space is required for the temporary array used during merging."
What is the bubble sort algorithm?,The bubble sort algorithm is a simple sorting algorithm that repeatedly swaps adjacent elements if they are in the wrong order. It has a worst-case time complexity of O(n^2) and is not efficient for large datasets.
Program / Code for Implementation of Bubble sort,"Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. 
In Bubble Sort algorithm, 

-traverse from left and compare adjacent elements and the higher one is placed at right side. 
-In this way, the largest element is moved to the rightmost end at first. 
-This process is then continued to find the second largest and place it and so on until the data is sorted.
Code in Java : 
import java.io.*;

class solution {
    
    // An optimized version of Bubble Sort
    static void bubbleSort(int arr[], int n)
    {
        int i, j, temp;
        boolean swapped;
        for (i = 0; i < n - 1; i++) {
            swapped = false;
            for (j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    
                    // Swap arr[j] and arr[j+1]
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }

            // If no two elements were
            // swapped by inner loop, then break
            if (swapped == false)
                break;
        }
    }

    // Function to print an array
    static void printArray(int arr[], int size)
    {
        int i;
        for (i = 0; i < size; i++)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }

    // Driver program
    public static void main(String args[])
    {
        int arr[] = { 64, 34, 25, 12, 22, 11, 90 };
        int n = arr.length;
        bubbleSort(arr, n);
        System.out.println(""Sorted array: "");
        printArray(arr, n);
    }
}
Complexity analysis : 
Time Complexity: O(N2)
Auxiliary Space: O(1)"
"What is the selection sort algorithm?",The selection sort algorithm is a simple sorting algorithm that selects the smallest element from an array and swaps it with the first element. It then repeats the process for the remaining elements in the array. It has a worst-case time complexity of O(n^2) and is not efficient for large datasets.
Program / Code for Implementation of Selection sort,"Selection sort is a simple and efficient sorting algorithm that works by repeatedly selecting the smallest (or largest) element from the unsorted portion of the list and moving it to the sorted portion of the list. 

The algorithm repeatedly selects the smallest (or largest) element from the unsorted portion of the list and swaps it with the first element of the unsorted part. This process is repeated for the remaining unsorted portion until the entire list is sorted. 


Code in Java : 
import java.io.*;
public class SelectionSort
{
    void sort(int arr[])
    {
        int n = arr.length;

        // One by one move boundary of unsorted subarray
        for (int i = 0; i < n-1; i++)
        {
            // Find the minimum element in unsorted array
            int min_idx = i;
            for (int j = i+1; j < n; j++)
                if (arr[j] < arr[min_idx])
                    min_idx = j;

            // Swap the found minimum element with the first
            // element
            int temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }

    // Prints the array
    void printArray(int arr[])
    {
        int n = arr.length;
        for (int i=0; i<n; ++i)
            System.out.print(arr[i]+"" "");
        System.out.println();
    }

    // Driver code to test above
    public static void main(String args[])
    {
        SelectionSort ob = new SelectionSort();
        int arr[] = {64,25,12,22,11};
        ob.sort(arr);
        System.out.println(""Sorted array"");
        ob.printArray(arr);
    }
}
Complexity analysis : 
Time Complexity: The time complexity of Selection Sort is O(N2) as there are two nested loops:
One loop to select an element of Array one by one = O(N)
Another loop to compare that element with every other Array element = O(N)
Therefore overall complexity = O(N) * O(N) = O(N*N) = O(N2)

Space Complexity: O(1) as the only extra memory used is for temporary variables while swapping two values in Array. The selection sort never makes more than O(N) swaps and can be useful when memory writing is costly. "
What is the insertion sort algorithm?,The insertion sort algorithm is a simple sorting algorithm that iterates through an array and inserts each element into its correct position in a sorted subarray. It has a worst-case time complexity of O(n^2) but is efficient for small datasets and partially sorted datasets.
Program / Code for Implementation of Insertion sort,"Insertion sort is a simple sorting algorithm that works by building a sorted array one element at a time. It is considered an “in-place” sorting algorithm, meaning it doesn’t require any additional memory space beyond the original array.
To achieve insertion sort, follow these steps:

We have to start with second element of the array as first element in the array is assumed to be sorted.
Compare second element with the first element and check if the second element is smaller then swap them.
Move to the third element and compare it with the second element, then the first element and swap as necessary to put it in the correct position among the first three elements.
Continue this process, comparing each element with the ones before it and swapping as needed to place it in the correct position among the sorted elements.
Repeat until the entire array is sorted.
Code in Java : 
public class InsertionSort {
    /*Function to sort array using insertion sort*/
    void sort(int arr[])
    {
        int n = arr.length;
        for (int i = 1; i < n; ++i) {
            int key = arr[i];
            int j = i - 1;

            /* Move elements of arr[0..i-1], that are
               greater than key, to one position ahead
               of their current position */
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
    }

    /* A utility function to print array of size n*/
    static void printArray(int arr[])
    {
        int n = arr.length;
        for (int i = 0; i < n; ++i)
            System.out.print(arr[i] + "" "");

        System.out.println();
    }

    // Driver method
    public static void main(String args[])
    {
        int arr[] = { 12, 11, 13, 5, 6 };

        InsertionSort ob = new InsertionSort();
        ob.sort(arr);

        printArray(arr);
    }
};
Complexity analysis : 
Time Complexity of Insertion Sort
Best case: O(n), If the list is already sorted, where n is the number of elements in the list.
Average case: O(n2), If the list is randomly ordered
Worst case: O(n2), If the list is in reverse order
Space Complexity of Insertion Sort
Auxiliary Space: O(1), Insertion sort requires O(1) additional space, making it a space-efficient sorting algorithm."
What is the topological sorting algorithm?,The topological sorting algorithm is an algorithm that sorts the nodes of a directed acyclic graph (DAG) in such a way that each node appears before all its successors. It can be used to schedule a series of dependent tasks or dependencies between modules in a software system.
What is the bucket sort algorithm?,"The bucket sort algorithm is a sorting algorithm that works by dividing an array into a finite number of buckets, each of which is then sorted separately. It can be used for datasets with a uniform distribution and has a time complexity of O(n) on average."
What is the radix sort algorithm?,"The radix sort algorithm is a non-comparative sorting algorithm that sorts elements by grouping them by individual digits or groups of digits that share the same significant position and sorting the groups in a specific order. It has a time complexity of O(d * (n + k)), where d is the number of digits in the largest number, n is the number of elements, and k is the range of the digits."
What is the counting sort algorithm?,The counting sort algorithm is a linear-time sorting algorithm that works by counting the number of occurrences of each distinct element in an array and using this information to place each element into its correct position in a sorted output array.
Program / Code for implementation of Heap Sort,"Approach : 
First convert the array into heap data structure using heapify, then one by one delete the root node of the Max-heap and replace it with the last node in the heap and then heapify the root of the heap. Repeat this process until size of heap is greater than 1.

Build a heap from the given input array.
Repeat the following steps until the heap contains only one element:
Swap the root element of the heap (which is the largest element) with the last element of the heap.
Remove the last element of the heap (which is now in the correct position).
Heapify the remaining elements of the heap.
The sorted array is obtained by reversing the order of the elements in the input array.

Code in Java : 
public class HeapSort {
    public void sort(int arr[])
    {
        int N = arr.length;

        // Build heap (rearrange array)
        for (int i = N / 2 - 1; i >= 0; i--)
            heapify(arr, N, i);

        // One by one extract an element from heap
        for (int i = N - 1; i > 0; i--) {
            // Move current root to end
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // call max heapify on the reduced heap
            heapify(arr, i, 0);
        }
    }

    // To heapify a subtree rooted with node i which is
    // an index in arr[]. n is size of heap
    void heapify(int arr[], int N, int i)
    {
        int largest = i; // Initialize largest as root
        int l = 2 * i + 1; // left = 2*i + 1
        int r = 2 * i + 2; // right = 2*i + 2

        // If left child is larger than root
        if (l < N && arr[l] > arr[largest])
            largest = l;

        // If right child is larger than largest so far
        if (r < N && arr[r] > arr[largest])
            largest = r;

        // If largest is not root
        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            // Recursively heapify the affected sub-tree
            heapify(arr, N, largest);
        }
    }

    /* A utility function to print array of size n */
    static void printArray(int arr[])
    {
        int N = arr.length;

        for (int i = 0; i < N; ++i)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }

    // Driver's code
    public static void main(String args[])
    {
        int arr[] = { 12, 11, 13, 5, 6, 7 };
        int N = arr.length;

        // Function call
        HeapSort ob = new HeapSort();
        ob.sort(arr);

        System.out.println(""Sorted array is"");
        printArray(arr);
    }
}
Complexity analysis : 
Time Complexity: O(N log N)
Space Complexity: O(log n), due to the recursive call stack. However, auxiliary space can be O(1) for iterative implementation."
what is heap sort ? ,Heap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements.
What is a search algorithm ? ,"Any algorithm which solves the search problem, namely, to retrieve information stored within some data structure, or calculated in the search space of a problem domain, either with discrete or continuous values.Search algorithms are designed to check or retrieve an element from any data structure where that element is being stored. They search for a target (key) in the search space."
What is linear search ? ,"The linear search algorithm works by sequentially iterating through the whole array or list from one end until the target element is found. If the element is found, it returns its index, else -1.
Code in Java : 
public class LinearSearch {
    public static void main(String[] args) {
        int[] nums = {2, 12, 15, 11, 7, 19, 45};
        int target = 7;
        System.out.println(search(nums, target));

    }

    static int search(int[] nums, int target) {
        for (int index = 0; index < nums.length; index++) {
            if (nums[index] == target) {
                return index;
            }
        }
        return -1;
    }
}
Time Complexity Analysis
The Best Case occurs when the target element is the first element of the array. The number of comparisons, in this case, is 1. So, the time complexity is O(1).

The Average Case: On average, the target element will be somewhere in the middle of the array. The number of comparisons, in this case, will be N/2. So, the time complexity will be O(N) (the constant being ignored).

The Worst Case occurs when the target element is the last element in the array or not in the array. In this case, we have to traverse the entire array, and so the number of comparisons will be N. So, the time complexity will be O(N)."
What is binary search ? ," The binary search algorithm works on the principle of divide and conquer and it is considered the best searching algorithm because it's faster to run. This type of searching algorithm is used to find the position of a specific value contained in a sorted array.
Code n Java : 
public class BinarySearch {
    public static void main(String[] args) {
        int[] nums = {2, 12, 15, 17, 27, 29, 45};
        int target = 17;
        System.out.println(search(nums, target));
    }

    static int search(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;

        while (start <= end) {
            int mid = start + (end - start) / 2;

            if (nums[mid] > target)
                end = mid - 1;
            else if (nums[mid] < target)
                start = mid + 1;
            else
                return mid;
        }
        return -1;
    }
}
Time Complexity Analysis
The Best Case occurs when the target element is the middle element of the array. The number of comparisons, in this case, is 1. So, the time complexity is O(1).

The Average Case: On average, the target element will be somewhere in the array. So, the time complexity will be O(logN).

The Worst Case occurs when the target element is not in the list or it is away from the middle element. So, the time complexity will be O(logN)."
Given a matrix if an element in the matrix is 0 then you will have to set its entire column and row to 0 and then return the matrix.,"
Code in Java:
import java.util.*;
public class Main {
    static ArrayList<ArrayList<Integer>> zeroMatrix(ArrayList<ArrayList<Integer>> matrix, int n, int m) {
        // int[] row = new int[n]; --> matrix[..][0]
        // int[] col = new int[m]; --> matrix[0][..]

        int col0 = 1;
        // step 1: Traverse the matrix and
        // mark 1st row & col accordingly:
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix.get(i).get(j) == 0) {
                    // mark i-th row:
                    matrix.get(i).set(0, 0);

                    // mark j-th column:
                    if (j != 0)
                        matrix.get(0).set(j, 0);
                    else
                        col0 = 0;
                }
            }
        }

        // Step 2: Mark with 0 from (1,1) to (n-1, m-1):
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                if (matrix.get(i).get(j) != 0) {
                    // check for col & row:
                    if (matrix.get(i).get(0) == 0 || matrix.get(0).get(j) == 0) {
                        matrix.get(i).set(j, 0);
                    }
                }
            }
        }

        //step 3: Finally mark the 1st col & then 1st row:
        if (matrix.get(0).get(0) == 0) {
            for (int j = 0; j < m; j++) {
                matrix.get(0).set(j, 0);
            }
        }
        if (col0 == 0) {
            for (int i = 0; i < n; i++) {
                matrix.get(i).set(0, 0);
            }
        }

        return matrix;
    }

    public static void main(String[] args) {
        ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();
        matrix.add(new ArrayList<>(Arrays.asList(1, 1, 1)));
        matrix.add(new ArrayList<>(Arrays.asList(1, 0, 1)));
        matrix.add(new ArrayList<>(Arrays.asList(1, 1, 1)));

        int n = matrix.size();
        int m = matrix.get(0).size();

        ArrayList<ArrayList<Integer>> ans = zeroMatrix(matrix, n, m);

        System.out.println(""The Final matrix is: "");
        for (ArrayList<Integer> row : ans) {
            for (Integer ele : row) {
                System.out.print(ele + "" "");
            }
            System.out.println();
        }
    }
}

Complexity Analysis
Time Complexity: O(2*(N*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.
Reason: In this approach, we are also traversing the entire matrix 2 times and each traversal is taking O(N*M) time complexity.
Space Complexity: O(1) as we are not using any extra space."
Given the number of rows n. Print the first n rows of Pascal’s triangle.,"Code in Java :
import java.util.*;

public class solution {
    public static List<Integer> generateRow(int row) {
        long ans = 1;
        List<Integer> ansRow = new ArrayList<>();
        ansRow.add(1); //inserting the 1st element

        //calculate the rest of the elements:
        for (int col = 1; col < row; col++) {
            ans = ans * (row - col);
            ans = ans / col;
            ansRow.add((int)ans);
        }
        return ansRow;
    }

    public static List<List<Integer>> pascalTriangle(int n) {
        List<List<Integer>> ans = new ArrayList<>();

        //store the entire pascal's triangle:
        for (int row = 1; row <= n; row++) {
            ans.add(generateRow(row));
        }
        return ans;
    }

    public static void main(String[] args) {
        int n = 5;
        List<List<Integer>> ans = pascalTriangle(n);
        for (List<Integer> it : ans) {
            for (int ele : it) {
                System.out.print(ele + "" "");
            }
            System.out.println();
        }
    }
}
Complexity Analysis : 
Time Complexity: O(n2), where n = number of rows(given).
Reason: We are generating a row for each single row. The number of rows is n. And generating an entire row takes O(n) time complexity.

Space Complexity: In this case, we are only using space to store the answer. That is why space complexity can still be considered as O(1)."
"Next permutation : find next lexicographically greater permutation Given an array Arr[] of integers, rearrange the numbers of the given array into the lexicographically next greater permutation of numbers.

If such an arrangement is not possible, it must rearrange to the lowest possible order (i.e., sorted in ascending order).","Code in Java :
import java.util.*;


import java.util.*;

public class solution{
    public static List< Integer > nextGreaterPermutation(List< Integer > A) {
        int n = A.size(); // size of the array.

        // Step 1: Find the break point:
        int ind = -1; // break point
        for (int i = n - 2; i >= 0; i--) {
            if (A.get(i) < A.get(i + 1)) {
                // index i is the break point
                ind = i;
                break;
            }
        }

        // If break point does not exist:
        if (ind == -1) {
            // reverse the whole array:
            Collections.reverse(A);
            return A;
        }

        // Step 2: Find the next greater element
        //         and swap it with arr[ind]:

        for (int i = n - 1; i > ind; i--) {
            if (A.get(i) > A.get(ind)) {
                int tmp = A.get(i);
                A.set(i, A.get(ind));
                A.set(ind, tmp);
                break;
            }
        }

        // Step 3: reverse the right half:
        List<Integer> sublist = A.subList(ind + 1, n);
        Collections.reverse(sublist);

        return A;
    }

    public static void main(String args[]) {
        List<Integer> A = Arrays.asList(new Integer[] {2, 1, 5, 4, 3, 0, 0});
        List<Integer> ans = nextGreaterPermutation(A);

        System.out.print(""The next permutation is: ["");
        for (int i = 0; i < ans.size(); i++) {
            System.out.print(ans.get(i) + "" "");
        }
        System.out.println(""]"");

    }

}

"
"Sort an array of 0s, 1s and 2s : Given an array consisting of only 0s, 1s, and 2s. Write a program to in-place sort the array without using inbuilt sort functions. 
","Code in Java : 
import java.util.*;

public class Main {
    public static void sortArray(ArrayList<Integer> arr, int n) {
        int low = 0, mid = 0, high = n - 1; // 3 pointers

        while (mid <= high) {
            if (arr.get(mid) == 0) {
                // swapping arr[low] and arr[mid]
                int temp = arr.get(low);
                arr.set(low, arr.get(mid));
                arr.set(mid, temp);

                low++;
                mid++;

            } else if (arr.get(mid) == 1) {
                mid++;

            } else {
                // swapping arr[mid] and arr[high]
                int temp = arr.get(mid);
                arr.set(mid, arr.get(high));
                arr.set(high, temp);

                high--;
            }
        }
    }

    public static void main(String args[]) {
        int n = 6;
        ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(new Integer[] {0, 2, 1, 2, 0, 1}));
        sortArray(arr, n);
        System.out.println(""After sorting:"");
        for (int i = 0; i < n; i++) {
            System.out.print(arr.get(i) + "" "");
        }
        System.out.println();

    }

}

Complexity Analysis
Time Complexity: O(N), where N = size of the given array.
Reason: We are using a single loop that can run at most N times.

Space Complexity: O(1) as we are not using any extra space."
"Stock Buy And Sell : You are given an array of prices where prices[i] is the price of a given stock on an ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.","Code in Java : 
import java.util.*;

public class Main {

    public static void main(String[] args) {
    int arr[] = {7,1,5,3,6,4};

    int maxPro = maxProfit(arr);
    System.out.println(""Max profit is: "" + maxPro);

    }
    static int maxProfit(int[] arr) {
    int maxPro = 0;
    int minPrice = Integer.MAX_VALUE;
    for (int i = 0; i < arr.length; i++) {
        minPrice = Math.min(minPrice, arr[i]);
        maxPro = Math.max(maxPro, arr[i] - minPrice);
    }
    return maxPro;
    }
}

Complexity Analysis
Time complexity: O(n)

Space Complexity: O(1)"
"Search in a sorted 2D matrix : You have been given a 2-D array 'mat' of size 'N x M' where 'N' and 'M' denote the number of rows and columns, respectively. The elements of each row are sorted in non-decreasing order. Moreover, the first element of a row is greater than the last element of the previous row (if it exists). You are given an integer ‘target’, and your task is to find if it exists in the given 'mat' or not.

","Code in Java : 

import java.util.*;

public class solution {
    public static boolean searchMatrix(ArrayList<ArrayList<Integer>> matrix, int target) {
        int n = matrix.size();
        int m = matrix.get(0).size();

        //apply binary search:
        int low = 0, high = n * m - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            int row = mid / m, col = mid % m;
            if (matrix.get(row).get(col) == target) return true;
            else if (matrix.get(row).get(col) < target) low = mid + 1;
            else high = mid - 1;
        }
        return false;
    }


    public static void main(String[] args) {
        ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();
        matrix.add(new ArrayList<>(Arrays.asList(1, 2, 3, 4)));
        matrix.add(new ArrayList<>(Arrays.asList(5, 6, 7, 8)));
        matrix.add(new ArrayList<>(Arrays.asList(9, 10, 11, 12)));

        boolean result = searchMatrix(matrix, 8);
        System.out.println(result ? ""true"" : ""false"");
    }
}


Complexity Analysis
Time Complexity: O(log(NxM)), where N = given row number, M = given column number.
Reason: We are applying binary search on the imaginary 1D array of size NxM.

Space Complexity: O(1) as we are not using any extra space."
"Find the Majority Element that occurs more than N/2 times : Given an array of N integers, write a program to return an element that occurs more than N/2 times in the given array. ","Code in Java : 


import java.util.*;

public class solution{
    public static int majorityElement(int []v) {
        //size of the given array:
        int n = v.length;
        int cnt = 0; // count
        int el = 0; // Element

        //applying the algorithm:
        for (int i = 0; i < n; i++) {
            if (cnt == 0) {
                cnt = 1;
                el = v[i];
            } else if (el == v[i]) cnt++;
            else cnt--;
        }

        //checking if the stored element
        // is the majority element:
        int cnt1 = 0;
        for (int i = 0; i < n; i++) {
            if (v[i] == el) cnt1++;
        }

        if (cnt1 > (n / 2)) return el;
        return -1;
    }

    public static void main(String args[]) {
        int[] arr = {2, 2, 1, 1, 1, 2, 2};
        int ans = majorityElement(arr);
        System.out.println(""The majority element is: "" + ans);

    }

}

Time Complexity: O(N) + O(N), where N = size of the given array.
Reason: The first O(N) is to calculate the count and find the expected majority element. The second one is to check if the expected element is the majority one or not.

Note: If the question states that the array must contain a majority element, in that case, we do not need the second check. Then the time complexity will boil down to O(N).

Space Complexity: O(1) as we are not using any extra space."
"Count Reverse Pairs : Given an array of numbers, you need to return the count of reverse pairs. Reverse Pairs are those pairs where i<j and arr[i]>2*arr[j].","Code in Java : 
import java.util.*;

public class solution {

    private static void merge(int[] arr, int low, int mid, int high) {
        ArrayList<Integer> temp = new ArrayList<>(); // temporary array
        int left = low;      // starting index of left half of arr
        int right = mid + 1;   // starting index of right half of arr

        //storing elements in the temporary array in a sorted manner//

        while (left <= mid && right <= high) {
            if (arr[left] <= arr[right]) {
                temp.add(arr[left]);
                left++;
            } else {
                temp.add(arr[right]);
                right++;
            }
        }

        // if elements on the left half are still left //

        while (left <= mid) {
            temp.add(arr[left]);
            left++;
        }

        //  if elements on the right half are still left //
        while (right <= high) {
            temp.add(arr[right]);
            right++;
        }

        // transfering all elements from temporary to arr //
        for (int i = low; i <= high; i++) {
            arr[i] = temp.get(i - low);
        }
    }

    public static int countPairs(int[] arr, int low, int mid, int high) {
        int right = mid + 1;
        int cnt = 0;
        for (int i = low; i <= mid; i++) {
            while (right <= high && arr[i] > 2 * arr[right]) right++;
            cnt += (right - (mid + 1));
        }
        return cnt;
    }

    public static int mergeSort(int[] arr, int low, int high) {
        int cnt = 0;
        if (low >= high) return cnt;
        int mid = (low + high) / 2 ;
        cnt += mergeSort(arr, low, mid);  // left half
        cnt += mergeSort(arr, mid + 1, high); // right half
        cnt += countPairs(arr, low, mid, high); //Modification
        merge(arr, low, mid, high);  // merging sorted halves
        return cnt;
    }

    public static int team(int[] skill, int n) {
        return mergeSort(skill, 0, n - 1);
    }

    public static void main(String[] args) {
        int[] a = {4, 1, 2, 3, 1};
        int n = 5;
        int cnt = team(a, n);
        System.out.println(""The number of reverse pair is: "" + cnt);
    }
}

Complexity Analysis
Time Complexity: O(2N*logN), where N = size of the given array.
Reason: Inside the mergeSort() we call merge() and countPairs() except mergeSort() itself. Now, inside the function countPairs(), though we are running a nested loop, we are actually iterating the left half once and the right half once in total. That is why, the time complexity is O(N). And the merge() function also takes O(N). The mergeSort() takes O(logN) time complexity. Therefore, the overall time complexity will be O(logN * (N+N)) = O(2N*logN).

Space Complexity: O(N), as in the merge sort We use a temporary array to store elements in sorted order."
Reverse a Linked List,"Code in Java :

import java.util.Stack;

// Node class represents a
// node in a linked list
class Node {
    // Data stored in the node
    int data;      
    // Pointer to the next
    // node in the list
    Node next;     

    // Constructor with both data
    // and next node as parameters
    Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }

    // Constructor with only data as
    // a parameter, sets next to null
    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class ReverseLinkedListUsingStack {


    // Function to reverse a singly
    // linked list using a recursion
    public static Node reverseLinkedList(Node head) {
        // Base case:
        // If the linked list is empty or has only one node,
        // return the head as it is already reversed.
        if (head == null || head.next == null) {
            return head;
        }
        
        // Recursive step:
        // Reverse the linked list starting
        // from the second node (head.next).
        Node newHead = reverseLinkedList(head.next);
        
        // Save a reference to the node following
        // the current 'head' node.
        Node front = head.next;
        
        // Make the 'front' node point to the current
        // 'head' node in the reversed order.
        front.next = head;
        
        // Break the link from the current 'head' node
        // to the 'front' node to avoid cycles.
        head.next = null;
        
        // Return the 'newHead,' which is the new
        // head of the reversed linked list.
        return newHead;
    }


    // Function to print the linked list
    public static void printLinkedList(Node head) {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data + "" "");
            temp = temp.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create a linked list with values 1, 3, 2, and 4
        Node head = new Node(1);
        head.next = new Node(3);
        head.next.next = new Node(2);
        head.next.next.next = new Node(4);

        // Print the original linked list
        System.out.print(""Original Linked List: "");
        printLinkedList(head);

        // Reverse the linked list
        head = reverseLinkedList(head);

        // Print the reversed linked list
        System.out.print(""Reversed Linked List: "");
        printLinkedList(head);
    }
}Complexity Analysis
Time Complexity: O(N) This is because we traverse the linked list twice: once to push the values onto the stack, and once to pop the values and update the linked list. Both traversals take O(N) time.

Space Complexity : O(1) No additional space is used explicitly for data structures or allocations during the linked list reversal process. However, it's important to note that there is an implicit use of stack space due to recursion. This recursive stack space stores function calls and associated variables during the recursive traversal and reversal of the linked list. Despite this, no extra memory beyond the program's existing execution space is allocated, hence maintaining a space complexity of O(1).

"
Find middle element in a Linked List,"Code in Java :                                
import java.util.*;

// Node class represents a node in a linked list
class Node {
    // Data stored in the node
    int data; 
     // Pointer to the next node in the list
    Node next;     

    // Constructor with both data
    // and next node as parameters
    Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }

    // Constructor with only data as
    // a parameter, sets next to null
    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class FindMiddleOfLinkedList {
    
    static Node findMiddle(Node head) {
        // Initialize the slow pointer to the head.
        Node slow = head; 
        
        // Initialize the fast pointer to the head.
        Node fast = head;   

        // Traverse the linked list using
        // the Tortoise and Hare algorithm.
        while (fast != null && fast.next != null && slow != null) {
            // Move fast two steps.
            fast = fast.next.next;  
            // Move slow one step.
            slow = slow.next;        
        }
        // Return the slow pointer,
        // which is now at the middle node.
        return slow;  
    }


    public static void main(String[] args) {
        // Creating a sample linked list:
        Node head = new Node(1);
        head.next = new Node(2);
        head.next.next = new Node(3);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(5);

        // Find the middle node
        Node middleNode = findMiddle(head);

        // Display the value of the middle node
        System.out.println(""The middle node value is: "" + middleNode.data);
    }
}
                                
Complexity Analysis
Time Complexity: O(N/2) The algorithm requires the 'fast' pointer to reach the end of the list which it does after approximately N/2 iterations (where N is the total number of nodes). Therefore, the maximum number of iterations needed to find the middle node is proportional to the number of nodes in the list, making the time complexity linear, or O(N/2) ~ O(N).

Space Complexity : O(1) There is constant space complexity because it uses a constant amount of extra space regardless of the size of the linked list. We only use a few variables to keep track of the middle position and traverse the list, and the memory required for these variables does not depend on the size of the list."
Merge two sorted Linked Lists,"Code in Java :                                 
// Importing required packages
import java.util.*;

// Node class represents a
// node in a linked list
class Node {
    // Data stored in the node
    int data;

    // Pointer to the next node in the list
    Node next;

    // Constructor with both data and
    // next node as parameters
    Node(int data1, Node next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data as a
    // parameter, sets next to null
    Node(int data1) {
        data = data1;
        next = null;
    }
}

// Class to merge two sorted linked lists
class MergeLinkedLists {

    // Function to merge two sorted linked lists
    static Node sortTwoLinkedLists(Node list1, Node list2) {
        // Create a dummy node to serve
        // as the head of the merged list
        Node dummyNode = new Node(-1);
        Node temp = dummyNode;

        // Traverse both lists simultaneously
        while (list1 != null && list2 != null) {
            // Compare elements of both lists and
            // link the smaller node to the merged list
            if (list1.data <= list2.data) {
                temp.next = list1;
                list1 = list1.next;
            } else {
                temp.next = list2;
                list2 = list2.next;
            }
            // Move the temporary pointer
            // to the next node
            temp = temp.next;
        }

        // If any list still has remaining
        // elements, append them to the merged list
        if (list1 != null) {
            temp.next = list1;
        } else {
            temp.next = list2;
        }
        // Return the merged list starting
        // from the next of the dummy node
        return dummyNode.next;
    }

    // Function to print the linked list
    static void printLinkedList(Node head) {
        Node temp = head;
        while (temp != null) {
            // Print the data of the current node
            System.out.print(temp.data + "" "");
            // Move to the next node
            temp = temp.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Example Linked Lists
        Node list1 = new Node(1);
        list1.next = new Node(3);
        list1.next.next = new Node(5);

        Node list2 = new Node(2);
        list2.next = new Node(4);
        list2.next.next = new Node(6);

        System.out.print(""First sorted linked list: "");
        printLinkedList(list1);

        System.out.print(""Second sorted linked list: "");
        printLinkedList(list2);

        Node mergedList = sortTwoLinkedLists(list1, list2);

        System.out.print(""Merged sorted linked list: "");
        printLinkedList(mergedList);
    }
}
                                
Complexity Analysis
Time Complexity: O(N1+N2) where N1 is the number of nodes in the first linked list and N1 in the second linked list as we traverse both linked lists in a single pass for merging without any additional loops or nested iterations.

Space Complexity : O(1) as no additional data structures or space is allocated for storing data, only a constant space for pointers to maintain for traversing the linked list."
Remove N-th node from the end of a Linked List,"Code in Java : 
class Node {
    public int data;
    public Node next;

    // Constructor for Node with data and next node
    public Node(int data1, Node next1) {
        data = data1;
        next = next1;
    }

    // Constructor for Node with only data (next set to null)
    public Node(int data1) {
        data = data1;
        next = null;
    }
}

public class Main {
    // Function to print the linked list
    public static void printLL(Node head) {
        while (head != null) {
            System.out.print(head.data + "" "");
            head = head.next;
        }
    }

    // Function to delete the Nth node from the end of the linked list
    public static Node DeleteNthNodefromEnd(Node head, int N) {
        // Create two pointers, fastp and slowp
        Node fastp = head;
        Node slowp = head;

        // Move the fastp pointer N nodes ahead
        for (int i = 0; i < N; i++)
            fastp = fastp.next;

        // If fastp becomes null, the Nth node from the end is the head
        if (fastp == null)
            return head.next;

        // Move both pointers until fastp reaches the end
        while (fastp.next != null) {
            fastp = fastp.next;
            slowp = slowp.next;
        }

        // Delete the Nth node from the end
        Node delNode = slowp.next;
        slowp.next = slowp.next.next;
        delNode = null;
        return head;
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int N = 3;
        Node head = new Node(arr[0]);
        head.next = new Node(arr[1]);
        head.next.next = new Node(arr[2]);
        head.next.next.next = new Node(arr[3]);
        head.next.next.next.next = new Node(arr[4]);

        // Delete the Nth node from the end and print the modified linked list
        head = DeleteNthNodefromEnd(head, N);
        printLL(head);
    }
}

Complexity Analysis
Time Complexity: O(N) since the fast pointer will traverse the entire linked list, where N is the length of the linked list.

Space Complexity: O(1), as we have not used any extra space."
Add two numbers represented as Linked Lists,"Code in Java : /**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(); 
        ListNode temp = dummy; 
        int carry = 0;
        while( l1 != null || l2 != null || carry == 1) {
            int sum = 0; 
            if(l1 != null) {
                sum += l1.val; 
                l1 = l1.next; 
            }
            
            if(l2 != null) {
                sum += l2.val; 
                l2 = l2.next; 
            }
            
            sum += carry; 
            carry = sum / 10; 
            ListNode node = new ListNode(sum % 10); 
            temp.next = node; 
            temp = temp.next; 
        }
        return dummy.next;
    }
}                                                                                                                                                                                                                                                                                                                                                                                                              Complexity analysis :                                                                                                                                                                                                                                                                                                                                                                                                           Time Complexity: O(max(m,n)). Assume that m and n represent the length of l1 and l2 respectively, the algorithm above iterates at most max(m,n) times.

Space Complexity: O(max(m,n)). The length of the new list is at most max(m,n)+1."
"Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list instead, you will be given access to the node to be deleted directly. It is guaranteed that the node to be deleted is not a tail node in the list.","Code in Java :                                                                                                                                                                                                                                                                                                                                                                                  import java.util.*;
class Node {
        int num;
        Node next;
        Node(int a) {
            num = a;
            next = null;
        }
}
class TUF{
//function to insert node at the end of the list
static Node insertNode(Node head,int val) {
    Node newNode = new Node(val);
    if(head == null) {
        head = newNode;
        return head;
    }
    Node temp = head;
    while(temp.next != null) temp = temp.next;
    temp.next = newNode;
    return head;
}
//function to get reference of the node to delete
static Node getNode(Node head,int val) {
    if(head==null)
    return null;
    while(head.num != val) head = head.next;
    
    return head;
}
//delete function as per the question
static void deleteNode(Node t) {
    if(t==null)
    return;
    t.num = t.next.num;
    t.next = t.next.next;
    return;
}
//printing the list function
static void printList(Node head) {
    if(head==null)
    return;
    while(head.next!=null ) {
        System.out.print(head.num+""->"");
        head = head.next;
    }
    System.out.println(head.num);
}

public static void main(String args[]) {
    Node head = null;
    //inserting node
    head=insertNode(head,1);
    head=insertNode(head,4);
    head=insertNode(head,2);
    head=insertNode(head,3);
    //printing given list
    System.out.println(""Given Linked List: "");
    printList(head);
    Node t = getNode(head,2);
    //delete node
    deleteNode(t);
    //list after deletion operation
    System.out.println(""Linked List after deletion: "");
    printList(head);
}
}
Time Complexity: O(1)

Reason: It is a two-step process that can be obtained in constant time.

Space Complexity: O(1)

Reason: No extra data structure is used."
"Rotate a Linked List : Given the head of a linked list, rotate the list to the right by k places.","Code in Java :                                                                                                                                                                                                                                                                                                                                                                                    import java.util.*;
class Node {
  int num;
  Node next;
  Node(int a) {
    num = a;
    next = null;
  }
}
class solution {
  //utility function to insert node at the end of the list
  static Node insertNode(Node head, int val) {
    Node newNode = new Node(val);
    if (head == null) {
      head = newNode;
      return head;
    }
    Node temp = head;
    while (temp.next != null) temp = temp.next;

    temp.next = newNode;
    return head;
  }
  //utility function to rotate list by k times
  static Node rotateRight(Node head, int k) {
    if (head == null || head.next == null) return head;
    for (int i = 0; i < k; i++) {
      Node temp = head;
      while (temp.next.next != null) temp = temp.next;
      Node end = temp.next;
      temp.next = null;
      end.next = head;
      head = end;
    }
    return head;
  }
  //utility function to print list
  static void printList(Node head) {
    while (head.next != null) {
      System.out.print(head.num + ""->"");
      head = head.next;
    }
    System.out.println(head.num);

  }

  public static void main(String args[]) {
    Node head = null;
    //inserting Node
    head = insertNode(head, 1);
    head = insertNode(head, 2);
    head = insertNode(head, 3);
    head = insertNode(head, 4);
    head = insertNode(head, 5);

    System.out.println(""Original list: "");
    printList(head);

    int k = 2;
    Node newHead = rotateRight(head, k); //calling function for rotating 
    right of the nodes by k times

    System.out.println(""After "" + k + "" iterations: "");
    printList(newHead); //list after rotating nodes

  }
}"
"3 Sum : Find triplets that add up to a zero - Given an array of N integers, your task is to find unique triplets that add up to give a sum of zero. In short, you need to return an array of all the unique triplets [arr[a], arr[b], arr[c]] such that i!=j, j!=k, k!=i, and their sum is equal to zero.","Code in Java : 


import java.util.*;

public class solution {
    public static List<List<Integer>> triplet(int n, int[] arr) {
        List<List<Integer>> ans = new ArrayList<>();
        Arrays.sort(arr);

        for (int i = 0; i < n; i++) {
            //remove duplicates:
            if (i != 0 && arr[i] == arr[i - 1]) continue;

            //moving 2 pointers:
            int j = i + 1;
            int k = n - 1;
            while (j < k) {
                int sum = arr[i] + arr[j] + arr[k];
                if (sum < 0) {
                    j++;
                } else if (sum > 0) {
                    k--;
                } else {
                    List<Integer> temp = Arrays.asList(arr[i], arr[j], arr[k]);
                    ans.add(temp);
                    j++;
                    k--;
                    //skip the duplicates:
                    while (j < k && arr[j] == arr[j - 1]) j++;
                    while (j < k && arr[k] == arr[k + 1]) k--;
                }
            }
        }

        return ans;
    }

    public static void main(String[] args) {
        int[] arr = { -1, 0, 1, 2, -1, -4};
        int n = arr.length;
        List<List<Integer>> ans = triplet(n, arr);
        for (List<Integer> it : ans) {
            System.out.print(""["");
            for (Integer i : it) {
                System.out.print(i + "" "");
            }
            System.out.print(""] "");
        }
        System.out.println();
    }
}


Complexity Analysis
Time Complexity: O(NlogN)+O(N2), where N = size of the array.
Reason: The pointer i, is running for approximately N times. And both the pointers j and k combined can run for approximately N times including the operation of skipping duplicates. So the total time complexity will be O(N2). 

Space Complexity: O(no. of quadruplets), This space is only used to store the answer. We are not using any extra space to solve this problem. So, from that perspective, space complexity can be written as O(1)."
Trapping Rainwater : Given an array of non-negative integers representation elevation of ground. Your task is to find the water that can be trapped after rain.,"Code in Java :                                                                                                                                                                                                                                                                                                                                                                                   import java.util.*;
class solution {
    static int trap(int[] height) {
        int n = height.length;
        int left = 0, right = n - 1;
        int res = 0;
        int maxLeft = 0, maxRight = 0;
        while (left <= right) {
            if (height[left] <= height[right]) {
                if (height[left] >= maxLeft) {
                    maxLeft = height[left];
                } else {
                    res += maxLeft - height[left];
                }
                left++;
            } else {
                if (height[right] >= maxRight) {
                    maxRight = height[right];
                } else {
                    res += maxRight - height[right];
                }
                right--;
            }
        }
        return res;
    }


    public static void main(String args[]) {
        int arr[] = {0,1,0,2,1,0,1,3,2,1,2,1};
        System.out.println(""The duplicate element is "" + trap(arr));
    }
}                                                                                                                                                                                                                                                                                                                                                                                                                     Complexity analysis : Time Complexity: O(N) because we are using 2 pointer approach.

Space Complexity: O(1) because we are not using anything extra."
"Remove Duplicates in-place from Sorted Array : Given an integer array sorted in non-decreasing order, remove the duplicates in place such that each unique element appears only once. The relative order of the elements should be kept the same.","Code in Java : 
import java.util.*;
public class Main {
    public static void main(String[] args) {
       int arr[] = {1,1,2,2,2,3,3};
        int k = removeDuplicates(arr);
        System.out.println(""The array after removing duplicate elements is "");
        for (int i = 0; i < k; i++) {
            System.out.print(arr[i] + "" "");
        }
    }
    static int removeDuplicates(int[] arr) {
        int i = 0;
        for (int j = 1; j < arr.length; j++) {
            if (arr[i] != arr[j]) {
                i++;
                arr[i] = arr[j];
            }
        }
        return i + 1;
    }
}

Complexity Analysis
Time Complexity: O(N)

Space Complexity: O(1)"
Given an array that contains only 1 and 0 return the count of maximum consecutive ones in the array.,"Code in Java :                                                                                                                                                                                                                                                                                                                                                                                       import java.util.*;
public class Main {
    static int findMaxConsecutiveOnes(int nums[]) {
        int cnt = 0;
        int maxi = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 1) {
                cnt++;
            } else {
                cnt = 0;
            }

            maxi = Math.max(maxi, cnt);
        }
        return maxi;
    }
    public static void main(String args[]) {
        int nums[] = { 1, 1, 0, 1, 1, 1 };
        int ans = findMaxConsecutiveOnes(nums);
        System.out.println(""The maximum  consecutive 1's are "" + ans);
    }
}                                                                                                                                                                                                                                                                                                                                                                                                               Complexity analysis : Time Complexity: O(N) since the solution involves only a single pass.

Space Complexity: O(1) because no extra space is used.

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      "
Implement Stack using Array,"Code in Java :                                                                                                                                                                                                                                                                                                                                                                                  import java.util.*;

public class solution {

    public static void main(String[] args) {

        stack s = new stack();
        s.push(6);
        s.push(3);
        s.push(7);
        System.out.println(""Top of the stack before deleting any element "" + s.top());
        System.out.println(""Size of the stack before deleting any element "" + s.size());
        System.out.println(""The element deleted is "" + s.pop());
        System.out.println(""Size of the stack after deleting an element "" + s.size());
        System.out.println(""Top of the stack after deleting an element "" + s.top());
    }
}
class stack {
    int size = 10000;
    int arr[] = new int[size];
    int top = -1;
    void push(int x) {
        top++;
        arr[top] = x;
    }
    int pop() {
        int x = arr[top];
        top--;
        return x;
    }
    int top() {
        return arr[top];
    }
    int size() {
        return top + 1;
    }
}                                                                                                                                                                                                                                                                                                                                                                                                       Complexity analysis  :Time Complexity: O(N)

Space Complexity: O(N)"
Implement Queue Using Array,"Code in Java :                                                                                                                                                                                                                                                                                                                                                                                        class Queue {

    private int arr[];
    private int start, end, currSize, maxSize;
    public Queue() {
        arr = new int[16];
        start = -1;
        end = -1;
        currSize = 0;
    }

    public Queue(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
        start = -1;
        end = -1;
        currSize = 0;
    }
    public void push(int newElement) {
        if (currSize == maxSize) {
            System.out.println(""Queue is full\nExiting..."");
            System.exit(1);
        }
        if (end == -1) {
            start = 0;
            end = 0;
        } else
            end = (end + 1) % maxSize;
        arr[end] = newElement;
        System.out.println(""The element pushed is "" + newElement);
        currSize++;
    }
    public int pop() {
        if (start == -1) {
            System.out.println(""Queue Empty\nExiting..."");
            System.exit(1);
        }
        int popped = arr[start];
        if (currSize == 1) {
            start = -1;
            end = -1;
        } else
            start = (start + 1) % maxSize;
        currSize--;
        return popped;
    }
    public int top() {
        if (start == -1) {
            System.out.println(""Queue is Empty"");
            System.exit(1);
        }
        return arr[start];
    }
    public int size() {
        return currSize;
    }

}

public class solution {
    public static void main(String args[]) {
        Queue q = new Queue(6);
        q.push(4);
        q.push(14);
        q.push(24);
        q.push(34);
        System.out.println(""The peek of the queue before deleting any element "" + q.top());
        System.out.println(""The size of the queue before deletion "" + q.size());
        System.out.println(""The first element to be deleted "" + q.pop());
        System.out.println(""The peek of the queue after deleting an element "" + q.top());
        System.out.println(""The size of the queue after deleting an element "" + q.size());
    }
}                                                                                                                                                                                                                                                                                                                                                                        Complexity analysis : Time Complexity:

pop function: O(1)

push function: O(1)

top function: O(1)

size function: O(1)

Space Complexity:

Whole Queue: O(n)"
Implement Stack using single Queue,"Code in Java :                                                                                                                                                                                                                                                                                                                                         import java.util.*;

public class solution {

    public static void main(String[] args) {
        stack s = new stack();
        s.push(3);
        s.push(2);
        s.push(4);
        s.push(1);
        System.out.println(""Top of the stack: "" + s.top());
        System.out.println(""Size of the stack before removing element: "" + s.size());
        System.out.println(""The deleted element is: "" + s.pop());
        System.out.println(""Top of the stack after removing element: "" + s.top());
        System.out.println(""Size of the stack after removing element: "" + s.size());
    }

}
class stack {
    Queue < Integer > q = new LinkedList < > ();
    void push(int x) {
        q.add(x);
        for (int i = 0; i < q.size() - 1; i++) {
            q.add(q.remove());
        }
    }
    int pop() {
        return q.remove();
    }
    int top() {
        return q.peek();
    }
    int size() {
        return q.size();
    }
}                                                                                                                                                                                                                                                                                                                                                                    Complexity analysis : Time Complexity: O(N)

Space Complexity: O(N)"
Implement Queue using Stack,"Code in Java :                                                                                                                                                                                                                                                                                                                                         import java.util.*;

class MyQueue {
    Stack < Integer > input = new Stack < > ();
    Stack < Integer > output = new Stack < > ();
    /** Initialize your data structure here. */
    public MyQueue() {

    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        System.out.println(""The element pushed is "" + x);
        input.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        // shift input to output 
        if (output.empty())
            while (input.empty() == false) {
                output.push(input.peek());
                input.pop();
            }


        int x = output.peek();
        output.pop();
        return x;
    }

    /** Get the front element. */
    public int peek() {
        // shift input to output 
        if (output.empty())
            while (input.empty() == false) {
                output.push(input.peek());
                input.pop();
            }
        return output.peek();
    }
    int size() {
        return (output.size() + input.size());
    }


}
class solution {
    public static void main(String args[]) {
        MyQueue q = new MyQueue();
        q.push(3);
        q.push(4);
        System.out.println(""The element poped is "" + q.pop());
        q.push(5);
        System.out.println(""The top element is "" + q.peek());
        System.out.println(""The size of the queue is "" + q.size());

    }
}                                                                                                                                                                                                                                                                                                                                                                  Complexity analysis : Time Complexity: O(1)  

Space Complexity: O(2N)"
"Check Balanced Parentheses. Given string str containing just the characters '(', ')', '{', '}', '[' and ']', check if the input string is valid and return true if the string is balanced otherwise return false.","Code in Java :                                                                                                                                                                                                                                                                                                                                          import java.util.*;
class TUF {
public static boolean isValid(String s) {
        Stack<Character> st = new Stack<Character>();
        for (char it : s.toCharArray()) {
            if (it == '(' || it == '[' || it == '{')
                st.push(it);
            else {
                if(st.isEmpty()) return false;
                char ch = st.pop(); 
                if((it == ')' && ch == '(') ||  (it == ']' && ch == '[') || (it == '}' && ch == '{')) continue;
                else return false;
            }
        }
        return st.isEmpty();
    }

 public static void main (String[] args) {
                
                String s=""()[{}()]"";
                if(isValid(s)==true)
                System.out.println(""True"");
                else
                System.out.println(""False"");
        }
}
Complexity Analysis : Time Complexity: O(N)

Space Complexity: O(N)"
"Rotten Oranges : Min time to rot all oranges : BFS : You will be given an m x n grid, where each cell has the following values : 

2  -  represents a rotten orange
1  -  represents a Fresh orange
0  -  represents an Empty Cell
Every minute, if a Fresh Orange is adjacent to a Rotten Orange in 4-direction ( upward, downwards, right, and left ) it becomes Rotten. 

Return the minimum number of minutes required such that none of the cells has a Fresh Orange. If it's not possible, return -1.","Code in Java :                                                                                                                                                                                                                                                                                                                                          import java.util.*;
class solution{
public static int orangesRotting(int[][] grid) {
        if(grid == null || grid.length == 0) return 0;
        int rows = grid.length;
        int cols = grid[0].length;
        Queue<int[]> queue = new LinkedList<>();
        int count_fresh = 0;
        //Put the position of all rotten oranges in queue
        //count the number of fresh oranges
        for(int i = 0 ; i < rows ; i++) {
            for(int j = 0 ; j < cols ; j++) {
                if(grid[i][j] == 2) {
                    queue.offer(new int[]{i , j});
                }
                if(grid[i][j] != 0) {
                    count_fresh++;
                }
            }
        }
       
        if(count_fresh == 0) return 0;
        int countMin = 0, cnt = 0;
        int dx[] = {0, 0, 1, -1};
        int dy[] = {1, -1, 0, 0};
        
        //bfs starting from initially rotten oranges
        while(!queue.isEmpty()) {
            int size = queue.size();
            cnt += size; 
            for(int i = 0 ; i < size ; i++) {
                int[] point = queue.poll();
                for(int j = 0;j<4;j++) {
                    int x = point[0] + dx[j];
                    int y = point[1] + dy[j];
                    
                    if(x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0 || 
                    grid[x][y] == 2) continue;
                    
                    grid[x][y] = 2;
                    queue.offer(new int[]{x , y});
                }
            }
            if(queue.size() != 0) {
                countMin++;
            }
        }
        return count_fresh == cnt ? countMin : -1;
    }
    public static void main(String args[])
    {
        int arr[][]={ {2,1,1} , {1,1,0} , {0,1,1} };
        int rotting = orangesRotting(arr);
        System.out.println(""Minimum Number of Minutes Required ""+rotting);
    }
}
Complexity analysis : 
Time Complexity: O ( n x n ) x 4    

Reason: Worst-case - We will be making each fresh orange rotten in the grid and for each rotten orange will check in 4 directions

Space Complexity: O ( n x n )

Reason: worst-case -  If all oranges are Rotten, we will end up pushing all rotten oranges into the Queue data structure"
Area of largest rectangle in Histogram,"Code in Java :
import java.util.*;
public class solution {
    static int largestRectangleArea(int histo[]) {
        Stack < Integer > st = new Stack < > ();
        int maxA = 0;
        int n = histo.length;
        for (int i = 0; i <= n; i++) {
            while (!st.empty() && (i == n || histo[st.peek()] >= histo[i])) {
                int height = histo[st.peek()];
                st.pop();
                int width;
                if (st.empty())
                    width = i;
                else
                    width = i - st.peek() - 1;
                maxA = Math.max(maxA, width * height);
            }
            st.push(i);
        }
        return maxA;
    }

    public static void main(String args[]) {
        int histo[] = {3, 1, 5, 6, 2, 3};
        System.out.println(""The largest area in the histogram is "" + largestRectangleArea(histo));
    }
}
Complexity analysis : 
Time Complexity: O( N ) + O (N)

Space Complexity: O(N)"
"Given an array of integers arr, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.","Code in Java : 
import java.util.*;
class TUF {
    public static int[] maxSlidingWindow(int[] a, int k) {
        int n = a.length;
        int[] r = new int[n - k + 1];
        int ri = 0;
        // store index
        Deque < Integer > q = new ArrayDeque < > ();
        for (int i = 0; i < a.length; i++) {
            // remove numbers out of range k
            if (!q.isEmpty() && q.peek() == i - k) {
                q.poll();
            }
            // remove smaller numbers in k range as they are useless
            while (!q.isEmpty() && a[q.peekLast()] < a[i]) {
                q.pollLast();
            }

            q.offer(i);
            if (i >= k - 1) {
                r[ri++] = a[q.peek()];
            }
        }
        return r;
    }
    public static void main(String args[]) {
        int i, j, n, k = 3, x;
        int arr[]={4,0,-1,3,5,3,6,8};
        int ans[] = maxSlidingWindow(arr, k);
        System.out.println(""Maximum element in every "" + k + "" window "");
        for (i = 0; i < ans.length; i++)
            System.out.print(ans[i] + ""  "");

    }
}
Complexity analysis : 
Time Complexity: O(N)

Space Complexity: O(K)"
Inorder Traversal of Binary Tree,"Code in Java : 
                            
import java.util.ArrayList;
import java.util.List;

// Node class for the binary tree
class Node {
    int data;
    Node left;
    Node right;
    
    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class BinaryTreeInorderTraversal {

    // Function to perform inorder traversal
    // of the tree and store values in 'arr'
    public static void inorder(Node root, List<Integer> arr) {
        // If the current node is null
        // (base case for recursion), return
        if (root == null) {
            return;
        }
        // Recursively traverse the left subtree
        inorder(root.left, arr);
        // Push the current node's
        // value into the list
        arr.add(root.data);
        // Recursively traverse 
        // the right subtree
        inorder(root.right, arr);
    }

    // Function to initiate inorder traversal
    // and return the resulting list
    public static List<Integer> inOrder(Node root) {
        // Create an empty list to
        // store inorder traversal values
        List<Integer> arr = new ArrayList<>();
        // Call the inorder traversal function
        inorder(root, arr);
        // Return the resulting list
        // containing inorder traversal values
        return arr;
    }

    // Main function
    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);

        // Getting inorder traversal
        List<Integer> result = inOrder(root);

        // Displaying the inorder traversal result
        System.out.print(""Inorder Traversal: "");
        // Output each value in the
        // inorder traversal result
        for (int val : result) {
            System.out.print(val + "" "");
        }
        System.out.println();
    }
}
Complexity analysis : 
                        
Time Complexity: O(N) where N is the number of nodes in the binary tree as each node of the binary tree is visited exactly once.

Space Complexity: O(N) where N is the number of nodes in the binary tree. This is because the recursive stack uses an auxiliary space which can potentially hold all nodes in the tree when dealing with a skewed tree (all nodes have only one child), consuming space proportional to the number of nodes.In the average case or for a balanced tree, the maximum number of nodes that could be in the stack at any given time would be roughly the height of the tree hence O(log2N)."
Preorder Traversal of Binary Tree,"Code in Java :
import java.util.ArrayList;
import java.util.List;

// Node class for
// the binary tree
class Node {
    int data;
    Node left;
    Node right;
    
    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class BinaryTreeTraversal {
    // Function to perform preorder traversal
    // of the tree and store values in 'arr'
    static void preorder(Node root, List<Integer> arr) {
        // If the current node is NULL
        // (base case for recursion), return
        if (root == null) {
            return;
        }
        // Push the current node's
        // value into the list
        arr.add(root.data);
        // Recursively traverse
        // the left subtree
        preorder(root.left, arr);
        // Recursively traverse
        // the right subtree
        preorder(root.right, arr);
    }

    // Function to initiate preorder traversal
    // and return the resulting list
    static List<Integer> preOrder(Node root) {
        // Create an empty list to
        // store preorder traversal values
        List<Integer> arr = new ArrayList<>();
        // Call the preorder traversal function
        preorder(root, arr);
        // Return the resulting list
        // containing preorder traversal values
        return arr;
    }

    // Main function
    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);

        // Getting preorder traversal
        List<Integer> result = preOrder(root);

        // Displaying the preorder traversal result
        System.out.print(""Preorder Traversal: "");
        // Output each value in the
        // preorder traversal result
        for (int val : result) {
            System.out.print(val + "" "");
        }
        System.out.println();
    }
}
Complexity analysis : 
Time Complexity: O(N) where N is the number of nodes in the binary tree as each node of the binary tree is visited exactly once.

Space Complexity: O(N) where N is the number of nodes in the binary tree as an additional space for array is allocated to store the values of all ‘N’ nodes of the binary tree."
Post-Order Traversal Of Binary Tree,"Code in Java : 
                            
import java.util.ArrayList;
import java.util.List;

// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;
    
    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class BinaryTreeTraversal {
    // Function to perform postorder
    // traversal recursively
    static void postorder(Node root, List<Integer> arr){
        // Base case: if root is null, return
        if(root == null){
            return;
        }
        // Traverse left subtree
        postorder(root.left, arr);
        // Traverse right subtree
        postorder(root.right, arr);
        // Visit the node
        // (append node's data to the array)
        arr.add(root.data);
    }

    // Function to get the postorder
    // traversal of a binary tree
    static List<Integer> postOrder(Node root){
        // Create a list to
        // store the traversal result
        List<Integer> arr = new ArrayList<>();
        // Perform postorder traversal
        // starting from the root
        postorder(root, arr);
        // Return the postorder
        // traversal result
        return arr;
    }

    // Function to print the
    // elements of a list
    static void printList(List<Integer> list) {
        // Iterate through the list
        // and print each element
        for (int num : list) {
            System.out.print(num + "" "");
        }
        System.out.println();
    }

    // Main function
    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);

        // Getting postorder traversal
        List<Integer> result = postOrder(root);

        // Printing the postorder
        // traversal result
        System.out.print(""Postorder traversal: "");
        printList(result);
    }
}
                            
                        
Complexity analysis : 
Time Complexity: O(N) where N is the number of nodes in the binary tree as each node of the binary tree is visited exactly once.

Space Complexity: O(N) where N is the number of nodes in the binary tree as an additional space for array is allocated to store the values of all ‘N’ nodes of the binary tree."
Morris Inorder Traversal of a Binary tree,"Code in Java : 
                            
import java.util.ArrayList;
import java.util.List;

// TreeNode structure
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int x) {
        val = x;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to perform iterative Morris
    // inorder traversal of a binary tree
    public List<Integer> getInorder(TreeNode root) {
        // List to store the
        // inorder traversal result
        List<Integer> inorder = new ArrayList<>();
        // Pointer to the current node,
        // starting from the root
        TreeNode cur = root;

        // Loop until the current
        // node is not NULL
        while (cur != null) {
            // If the current node's
            // left child is NULL
            if (cur.left == null) {
                // Add the value of the current
                // node to the inorder list
                inorder.add(cur.val);
                // Move to the right child
                cur = cur.right;
            } else {
                // If the left child is not NULL,
                // find the predecessor (rightmost node
                // in the left subtree)
                TreeNode prev = cur.left;
                while (prev.right != null && prev.right != cur) {
                    prev = prev.right;
                }

                // If the predecessor's right child
                // is NULL, establish a temporary link
                // and move to the left child
                if (prev.right == null) {
                    prev.right = cur;
                    cur = cur.left;
                } else {
                    // If the predecessor's right child
                    // is already linked, remove the link,
                    // add current node to inorder list,
                    // and move to the right child
                    prev.right = null;
                    inorder.add(cur.val);
                    cur = cur.right;
                }
            }
        }

        // Return the inorder
        // traversal result
        return inorder;
    }

    public static void main(String[] args) {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.left.right.right = new TreeNode(6);

        Solution sol = new Solution();

        List<Integer> inorder = sol.getInorder(root);

        System.out.print(""Binary Tree Morris Inorder Traversal: "");
        for (int i = 0; i < inorder.size(); i++) {
            System.out.print(inorder.get(i) + "" "");
        }
        System.out.println();
    }
}
 Complexity analysis :                          
 Time Complexity: O(2N) where N is the number of nodes in the Binary Tree.

The time complexity is linear, as each node is visited at most twice (once for establishing the temporary link and once for reverting it).
In each step, we perform constant-time operations, such as moving to the left or right child and updating pointers.
Space Complexity: O(1) The space complexity is constant, as the algorithm uses only a constant amount of extra space irrespective of the input size.

Morris Traversal does not use any additional data structures like stacks or recursion, making it an in-place algorithm.
The only space utilised is for a few auxiliary variables, such as pointers to current and in-order predecessor nodes."
Morris Preorder Traversal of a Binary Tree,"Code in Java : 
                            
import java.util.ArrayList;
import java.util.List;

// TreeNode structure
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int x) {
        val = x;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to perform iterative Morris
    // preorder traversal of a binary tree
    public List<Integer> getPreorder(TreeNode root) {
        // List to store the
        // preorder traversal result
        List<Integer> preorder = new ArrayList<>();

        // Pointer to the current node,
        // starting with the root
        TreeNode cur = root;

        // Iterate until the
        // current node becomes null
        while (cur != null) {
            // If the current node
            // has no left child
            if (cur.left == null) {
                // Add the value of the
                // current node to the preorder list
                preorder.add(cur.val);

                // Move to the right child
                cur = cur.right;
            } else {
                // If the current node has a left child
                // Create a pointer to traverse to the
                // rightmost node in the left subtree
                TreeNode prev = cur.left;

                // Traverse to the rightmost node in the
                // left subtree or until we find a node
                // whose right child is not yet processed
                while (prev.right != null && prev.right != cur) {
                    prev = prev.right;
                }

                // If the right child of the
                // rightmost node is null
                if (prev.right == null) {
                    // Set the right child of the
                    // rightmost node to the current node
                    prev.right = cur;

                    // Move to the left child
                    cur = cur.left;
                } else {
                    // If the right child of the
                    // rightmost node is not null
                    // Reset the right child to null
                    prev.right = null;

                    // Add the value of the
                    // current node to the preorder list
                    preorder.add(cur.val);

                    // Move to the right child
                    cur = cur.right;
                }
            }
        }

        // Return the resulting
        // preorder traversal list
        return preorder;
    }

    public static void main(String[] args) {
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.left.right.right = new TreeNode(6);

        Solution sol = new Solution();

        List<Integer> preorder = sol.getPreorder(root);

        System.out.print(""Binary Tree Morris Preorder Traveral: "");
        for (int i = 0; i < preorder.size(); i++) {
            System.out.print(preorder.get(i) + "" "");
        }
        System.out.println();
    }
}
 Complexity analysis : 
Time Complexity: O(2N) where N is the number of nodes in the Binary Tree.

The time complexity is linear, as each node is visited at most twice (once for establishing the temporary link and once for reverting it).
In each step, we perform constant-time operations, such as moving to the left or right child and updating pointers.
Space Complexity: O(1) The space complexity is constant, as the algorithm uses only a constant amount of extra space irrespective of the input size.

Morris Traversal does not use any additional data structures like stacks or recursion, making it an in-place algorithm.
The only space utilised is for a few auxiliary variables, such as pointers to current and in-order predecessor nodes.                          
                        "
Right/Left view of binary tree,"Code in Java : 
                                
import java.util.ArrayList;
import java.util.List;

// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class Solution {

    // Function to return the Right view of the binary tree
    public List<Integer> rightsideView(Node root) {
        // List to store the result
        List<Integer> res = new ArrayList<>();

        // Call the recursive function
        // to populate the right-side view
        recursionRight(root, 0, res);

        return res;
    }

    // Function to return the Left view of the binary tree
    public List<Integer> leftsideView(Node root) {
        // List to store the result
        List<Integer> res = new ArrayList<>();

        // Call the recursive function
        // to populate the left-side view
        recursionLeft(root, 0, res);

        return res;
    }

    // Recursive function to traverse the
    // binary tree and populate the left-side view
    private void recursionLeft(Node root, int level, List<Integer> res) {
        // Check if the current node is null
        if (root == null) {
            return;
        }

        // Check if the size of the result list
        // is equal to the current level
        if (res.size() == level) {
            // If equal, add the value of the
            // current node to the result list
            res.add(root.data);
        }

        // Recursively call the function for the
        // left child with an increased level
        recursionLeft(root.left, level + 1, res);

        // Recursively call the function for the
        // right child with an increased level
        recursionLeft(root.right, level + 1, res);
    }

    // Recursive function to traverse the
    // binary tree and populate the right-side view
    private void recursionRight(Node root, int level, List<Integer> res) {
        // Check if the current node is null
        if (root == null) {
            return;
        }

        // Check if the size of the result list
        // is equal to the current level
        if (res.size() == level) {
            // If equal, add the value of the
            // current node to the result list
            res.add(root.data);

            // Recursively call the function for the
            // right child with an increased level
            recursionRight(root.right, level + 1, res);

            // Recursively call the function for the
            // left child with an increased level
            recursionRight(root.left, level + 1, res);
        }
    }

    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.left.left = new Node(4);
        root.left.right = new Node(10);
        root.left.left.right = new Node(5);
        root.left.left.right.right = new Node(6);
        root.right = new Node(3);
        root.right.right = new Node(10);
        root.right.left = new Node(9);

        Solution solution = new Solution();

        // Get the Right View traversal
        List<Integer> rightView = solution.rightsideView(root);

        // Print the result for Right View
        System.out.print(""Right View Traversal: "");
        for (int node : rightView) {
            System.out.print(node + "" "");
        }
        System.out.println();

        // Get the Left View traversal
        List<Integer> leftView = solution.leftsideView(root);

        // Print the result for Left ViewTime Complexity: O(log2N) where N is the number of nodes in the Binary Tree. This complexity arises as we travel along the height of the Binary Tree. For a balanced binary tree, the height is log2N but in the worst case when the tree is skewed, the complexity becomes O(N).

Space Complexity : O(log2N) where N is the number of nodes in the Binary Tree. This complexity arises because we store the leftmost and rightmost nodes in an additional vector. The size of this result vector is proportional to the height of the Binary Tree which will be log2N when the tree is balanced and O(N) in the worst case of a skewed tree.

O(H): Recursive Stack Space is used to calculate the height of the tree at each node which is proportional to the height of the tree.
The recursive nature of the getHeight function, which incurs space on the call stack for each recursive call until it reaches the leaf nodes or the height of the tree.
        System.out.print(""Left View Traversal: "");
        for (int node : leftView) {
            System.out.print(node + "" "");
        }
        System.out.println();
    }
}
                                
 Complexity analysis : 
                           "
Bottom view of a Binary Tree,"Code in Java : 
                            
import java.util.*;

// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;
    
    // Constructor to initialize
    // the node with a value
    public Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to return the
    // bottom view of the binary tree
    public List<Integer> bottomView(Node root) {
        // List to store the result
        List<Integer> ans = new ArrayList<>();
        
        // Check if the tree is empty
        if(root == null) {
            return ans;
        }
        
        // Map to store the bottom view nodes
        // based on their vertical positions
        Map<Integer, Integer> mpp = new TreeMap<>();
        
        // Queue for BFS traversal, each
        // element is a pair containing node
        // and its vertical position
        Queue<Pair<Node, Integer>> q = new LinkedList<>();
        
        // Push the root node with its vertical
        // position (0) into the queue
        q.add(new Pair<>(root, 0));
        
        // BFS traversal
        while(!q.isEmpty()) {
            // Retrieve the node and its vertical
            // position from the front of the queue
            Pair<Node, Integer> pair = q.poll();
            Node node = pair.getKey();
            int line = pair.getValue();
            
            // Update the map with the node's data
            // for the current vertical position
            mpp.put(line, node.data);
            
            // Process left child
            if(node.left != null) {
                // Push the left child with a decreased
                // vertical position into the queue
                q.add(new Pair<>(node.left, line - 1));
            }
            
            // Process right child
            if(node.right != null) {
                // Push the right child with an increased
                // vertical position into the queue
                q.add(new Pair<>(node.right, line + 1));
            }
        }
        
        // Transfer values from the
        // map to the result list
        for(Map.Entry<Integer, Integer> entry : mpp.entrySet()) {
            ans.add(entry.getValue());
        }
        
        return ans;
    }

    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.left.left = new Node(4);
        root.left.right = new Node(10);
        root.left.left.right = new Node(5);
        root.left.left.right.right = new Node(6);
        root.right = new Node(3);
        root.right.right = new Node(10);
        root.right.left = new Node(9);

        Solution solution = new Solution();

        // Get the Bottom View traversal
        List<Integer> bottomView = solution.bottomView(root);

        // Print the result
        System.out.println(""Bottom View Traversal: "");
        for(int node : bottomView) {
            System.out.print(node + "" "");
        }
    }
}
                            
Complexity Analysis
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the BFS traversal.

Space Complexity: O(N/2 + N/2) where N represents the number of nodes in the Binary Tree.

The main space consuming data structure is the queue used for BFS traversal. It acquires space proportional to the number of nodes in the level it is exploring hence in the worst case of a balanced binary tree, the queue will have at most N/2 nodes which is the maximum width.
Additionally, the map is used to store the top view nodes based on their vertical positions hence its complexity will also be proportional to the greatest width level. In the worst case, it may have N/2 entries as well."
Top view of a Binary Tree,"Code in Java : 
                            
import java.util.*;

// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;
    
    // Constructor to initialize
    // the node with a value
    public Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to return the
    // top view of the binary tree
    public List<Integer> topView(Node root) {
        // List to store the result
        List<Integer> ans = new ArrayList<>();
        
        // Check if the tree is empty
        if (root == null) {
            return ans;
        }
        
        // Map to store the top view nodes
        // based on their vertical positions
        Map<Integer, Integer> mpp = new TreeMap<>();
        
        // Queue for BFS traversal, each element
        // is a pair containing node 
        // and its vertical position
        Queue<Pair<Node, Integer>> q = new LinkedList<>();
        
        // Push the root node with its vertical
        // position (0) into the queue
        q.add(new Pair<>(root, 0));
        
        // BFS traversal
        while (!q.isEmpty()) {
            // Retrieve the node and its vertical
            // position from the front of the queue
            Pair<Node, Integer> pair = q.poll();
            Node node = pair.getKey();
            int line = pair.getValue();
            
            // If the vertical position is not already
            // in the map, add the node's data to the map
            if (!mpp.containsKey(line)) {
                mpp.put(line, node.data);
            }
            
            // Process left child
            if (node.left != null) {
                // Push the left child with a decreased
                // vertical position into the queue
                q.add(new Pair<>(node.left, line - 1));
            }
            
            // Process right child
            if (node.right != null) {
                // Push the right child with an increased
                // vertical position into the queue
                q.add(new Pair<>(node.right, line + 1));
            }
        }
        
        // Transfer values from the
        // map to the result list
        for (int value : mpp.values()) {
            ans.add(value);
        }
        
        return ans;
    }

    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.left.left = new Node(4);
        root.left.right = new Node(10);
        root.left.left.right = new Node(5);
        root.left.left.right.right = new Node(6);
        root.right = new Node(3);
        root.right.right = new Node(10);
        root.right.left = new Node(9);

        Solution solution = new Solution();

        // Get the top view traversal
        List<Integer> topView = solution.topView(root);

        // Print the result
        System.out.println(""Vertical Traversal: "");
        for (int node : topView) {
            System.out.print(node + "" "");
        }
    }
}
                            
Complexity Analysis
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the BFS traversal.

Space Complexity: O(N/2 + N/2) where N represents the number of nodes in the Binary Tree.

The main space consuming data structure is the queue used for BFS traversal. It acquires space proportional to the number of nodes in the level it is exploring hence in the worst case of a balanced binary tree, the queue will have at most N/2 nodes which is the maximum width.
Additionally, the map is used to store the top view nodes based on their vertical positions hence its complexity will also be proportional to the greatest width level. In the worst case, it may have N/2 entries as well."
Program / code for Preorder Inorder Postorder Traversals in One Traversal,"Code in Java : 
                            
import java.util.*;

// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class TreeTraversal {
    // Function to get the Preorder,
    // Inorder and Postorder traversal
    // Of Binary Tree in One traversal
    public static List<List<Integer>> preInPostTraversal(Node root) {
        // Lists to store traversals
        List<Integer> pre = new ArrayList<>();
        List<Integer> in = new ArrayList<>();
        List<Integer> post = new ArrayList<>();

        // If the tree is empty,
        // return empty traversals
        if (root == null) {
            return new ArrayList<>();
        }

        // Stack to maintain nodes
        // and their traversal state
        Stack<Pair<Node, Integer>> st = new Stack<>();

        // Start with the root node
        // and state 1 (preorder)
        st.push(new Pair<>(root, 1));

        while (!st.empty()) {
            Pair<Node, Integer> it = st.pop();

            // this is part of pre
            if (it.getValue() == 1) {
                // Store the node's data
                // in the preorder traversal
                pre.add(it.getKey().data);
                // Move to state 2
                // (inorder) for this node
                it.setValue(2);
                // Push the updated state
                // back onto the stack
                st.push(it);

                // Push left child onto
                // the stack for processing
                if (it.getKey().left != null) {
                    st.push(new Pair<>(it.getKey().left, 1));
                }
            }

            // this is a part of in
            else if (it.getValue() == 2) {
                // Store the node's data
                // in the inorder traversal
                in.add(it.getKey().data);
                // Move to state 3
                // (postorder) for this node
                it.setValue(3);
                // Push the updated state
                // back onto the stack
                st.push(it);

                // Push right child onto
                // the stack for processing
                if (it.getKey().right != null) {
                    st.push(new Pair<>(it.getKey().right, 1));
                }
            }

            // this is part of post
            else {
                // Store the node's data
                // in the postorder traversal
                post.add(it.getKey().data);
            }
        }

        // Returning the traversals
        List<List<Integer>> result = new ArrayList<>();
        result.add(pre);
        result.add(in);
        result.add(post);
        return result;
    }

    // Function to print the
    // elements of a list
    public static void printList(List<Integer> list) {
        // Iterate through the list
        // and print each element
        for (int num : list) {
            System.out.print(num + "" "");
        }
        System.out.println();
    }

    // Main function
    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);

        // Getting the pre-order, in-order,
        // and post-order traversals
        List<Integer> pre, in, post;
        List<List<Integer>> traversals = preInPostTraversal(root);

        // Extracting the traversals
        // from the result
        pre = traversals.get(0);
        in = traversals.get(1);
        post = traversals.get(2);

        // Printing the traversals
        System.out.print(""Preorder traversal: "");
        printList(pre);

        System.out.print(""Inorder traversal: "");
        printList(in);

        System.out.print(""Postorder traversal: "");
        printList(post);
    }
}
                            
Complexity analysis : 
Time Complexity: O(3N) where N is the number of nodes in the Binary Tree. Each node is processed once for each traversal type (pre-order, in-order, and post-order). Hence, the algorithm effectively visits each node three times in total across the three traversal types.

Space Complexity: O(4N) where N is the number of nodes in the Binary Tree. The following additional data structures are used:A stack to maintain traversal states, requiring additional space proportional to the maximum number of nodes in the stack at any point during traversal.Three vectors to store the preorder, inorder and postorder traversal. These arrays collectively occupy space proportional to the total number of nodes in the tree. Hence, 3N is added to the space complexity."
"Given a Binary Tree, return the Vertical Order Traversal of it starting from the Leftmost level to the Rightmost level.","Code in Java : 
                            
import java.util.*;

// Node class for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    public Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to perform vertical order traversal
    // and return a 2D ArrayList of node values
    public List<List<Integer>> findVertical(Node root) {
        // Map to store nodes based on
        // vertical and level information
        Map<Integer, Map<Integer, TreeSet<Integer>>> nodes = new TreeMap<>();

        // Queue for BFS traversal, each
        // element is a pair containing node
        // and its vertical and level information
        Queue<Pair<Node, Pair<Integer, Integer>>> todo = new LinkedList<>();

        // Push the root node with initial vertical
        // and level values (0, 0)
        todo.add(new Pair<>(root, new Pair<>(0, 0)));

        // BFS traversal
        while (!todo.isEmpty()) {
            // Retrieve the node and its vertical
            // and level information from
            // the front of the queue
            Pair<Node, Pair<Integer, Integer>> p = todo.poll();
            Node temp = p.getKey();

            // Extract the vertical and level information
            // x -> vertical
            int x = p.getValue().getKey();
            // y -> level
            int y = p.getValue().getValue();

            // Insert the node value into the
            // corresponding vertical and level
            // in the map
            nodes.computeIfAbsent(x, k -> new TreeMap<>())
                 .computeIfAbsent(y, k -> new TreeSet<>())
                 .add(temp.data);

            // Process left child
            if (temp.left != null) {
                todo.add(new Pair<>(temp.left, new Pair<>(x - 1, y + 1)));
            }

            // Process right child
            if (temp.right != null) {
                todo.add(new Pair<>(temp.right, new Pair<>(x + 1, y + 1)));
            }
        }

        // Prepare the final result list
        // by combining values from the map
        List<List<Integer>> ans = new ArrayList<>();
        for (Map.Entry<Integer, Map<Integer, TreeSet<Integer>>> entry : nodes.entrySet()) {
            List<Integer> col = new ArrayList<>();
            for (TreeSet<Integer> set : entry.getValue().values()) {
                // Insert node values
                // into the column list
                col.addAll(set);
            }
            // Add the column list
            // to the final result
            ans.add(col);
        }
        return ans;
    }

    // Helper function to
    // print the result
    private static void printResult(List<List<Integer>> result) {
        for (List<Integer> level : result) {
            for (int node : level) {
                System.out.print(node + "" "");
            }
            System.out.println();
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.left.left = new Node(4);
        root.left.right = new Node(10);
        root.left.left.right = new Node(5);
        root.left.left.right.right = new Node(6);
        root.right = new Node(3);
        root.right.right = new Node(10);
        root.right.left = new Node(9);

        Solution solution = new Solution();

        // Get the Vertical traversal
        List<List<Integer>> verticalTraversal = solution.findVertical(root);

        // Print the result
        System.out.print(""Vertical Traversal: "");
        printResult(verticalTraversal);
    }
}
                            
                        "
Given a Binary Tree and a reference to a root belonging to it. Return the path from the root node to the given leaf node.,"Code in Java : 
                            
import java.util.ArrayList;
import java.util.List;

// TreeNode structure
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int x) {
        val = x;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to find the path from the
    // root to a given node with value 'x'
    public boolean getPath(TreeNode root, List<Integer> arr, int x) {
        // Base case: If the current
        // node is null, return false
        if (root == null) {
            return false;
        }

        // Add the current node's
        // value to the path list
        arr.add(root.val);

        // If the current node's value is equal
        // to the target value 'x', return true
        if (root.val == x) {
            return true;
        }

        // Recursively search for the target value
        // 'x' in the left and right subtrees
        if (getPath(root.left, arr, x) || getPath(root.right, arr, x)) {
            return true;
        }

        // If the target value 'x' is not found
        // in the current path, backtrack
        arr.remove(arr.size() - 1);
        return false;
    }

    // Function to find and return the path from
    // the root to a given node with value 'B'
    public List<Integer> solve(TreeNode A, int B) {
        // Initialize an empty
        // list to store the path
        List<Integer> arr = new ArrayList<>();

        // If the root node is null,
        // return the empty path list
        if (A == null) {
            return arr;
        }

        // Call the getPath function to find
        // the path to the node with value 'B'
        getPath(A, arr, B);

        // Return the path list
        return arr;
    }

    public static void main(String[] args) {
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(5);
        root.right = new TreeNode(1);
        root.left.left = new TreeNode(6);
        root.left.right = new TreeNode(2);
        root.right.left = new TreeNode(0);
        root.right.right = new TreeNode(8);
        root.left.right.left = new TreeNode(7);
        root.left.right.right = new TreeNode(4);

        Solution sol = new Solution();

        int targetLeafValue = 7;

        List<Integer> path = sol.solve(root, targetLeafValue);

        System.out.print(""Path from root to leaf with value "" +
                targetLeafValue + "": "");
        for (int i = 0; i < path.size(); ++i) {
            System.out.print(path.get(i));
            if (i < path.size() - 1) {
                System.out.print("" -> "");
            }
        }
    }
}
                            
                        
Complexity Analysis
Time Complexity: O(N) where N is the number of nodes in the binary tree as each node of the binary tree is visited exactly once in the inorder traversal.

Space Complexity: O(N) awhere N is the number of nodes in the binary tree. This is because the stack can potentially hold all nodes in the tree when dealing with a skewed tree (all nodes have only one child), consuming space proportional to the number of nodes.

O(H): In the average case or for a balanced tree, the maximum number of nodes that could be in the stack at any given time would be roughly the height of the tree hence O(log2N)."
Maximum Width of a Binary Tree,"Code in Java : 
                            
import java.util.LinkedList;
import java.util.Queue;

// TreeNode structure
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function widthOfBinaryTree to find the
    // maximum width of the Binary Tree
    public int widthOfBinaryTree(TreeNode root) {
        // If the root is null,
        // the width is zero
        if (root == null) {
            return 0;
        }

        // Initialize a variable 'ans'
        // to store the maximum width
        int ans = 0;

        // Create a queue to perform level-order
        // traversal, where each element is a pair
        // of TreeNode and its position in the level
        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();
        // Push the root node and its
        // position (0) into the queue
        q.add(new Pair<>(root, 0));

        // Perform level-order traversal
        while (!q.isEmpty()) {
            // Get the number of
            // nodes at the current level
            int size = q.size();
            // Get the position of the front
            // node in the current level
            int mmin = q.peek().getValue();

            // Store the first and last positions
            // of nodes in the current level
            int first, last;

            // Process each node
            // in the current level
            for (int i = 0; i < size; i++) {
                // Calculate current position relative
                // to the minimum position in the level
                int cur_id = q.peek().getValue() - mmin;
                // Get the current node
                TreeNode node = q.peek().getKey();
                // Poll the front node from the queue
                q.poll();

                // If this is the first node in the level,
                // update the 'first' variable
                if (i == 0) {
                    first = cur_id;
                }

                // If this is the last node in the level,
                // update the 'last' variable
                if (i == size - 1) {
                    last = cur_id;
                }

                // Enqueue the left child of the
                // current node with its position
                if (node.left != null) {
                    q.add(new Pair<>(node.left, cur_id * 2 + 1));
                }

                // Enqueue the right child of the
                // current node with its position
                if (node.right != null) {
                    q.add(new Pair<>(node.right, cur_id * 2 + 2));
                }
            }

            // Update the maximum width by calculating
            // the difference between the first and last
            // positions, and adding 1
            ans = Math.max(ans, last - first + 1);
        }

        // Return the maximum
        // width of the binary tree
        return ans;
    }

    public static void main(String[] args) {
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(5);
        root.right = new TreeNode(1);
        root.left.left = new TreeNode(6);
        root.left.right = new TreeNode(2);
        root.right.left = new TreeNode(0);
        root.right.right = new TreeNode(8);
        root.left.right.left = new TreeNode(7);
        root.left.right.right = new TreeNode(4);

        Solution sol = new Solution();

        int maxWidth = sol.widthOfBinaryTree(root);

        System.out.println(""Maximum width of the binary tree is: "" + maxWidth);
    }
}
                            
                        
Complexity analysis : 
Time Complexity: O(N) where N is the number of nodes in the binary tree. Each node of the binary tree is enqueued and dequeued exactly once, hence all nodes need to be processed and visited. Processing each node takes constant time operations which contributes to the overall linear time complexity.

Space Complexity: O(N) where N is the number of nodes in the binary tree. In the worst case, the queue has to hold all the nodes of the last level of the binary tree, the last level could at most hold N/2 nodes hence the space complexity of the queue is proportional to O(N)."
Level Order Traversal of a Binary Tree,"Code in Java : 
                            
import java.util.*;

// TreeNode class represents
// a node in a binary tree
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    // Default constructor for TreeNode
    TreeNode() {
        this.val = 0;
        this.left = null;
        this.right = null;
    }

    // Constructor with a value
    // parameter for TreeNode
    TreeNode(int x) {
        this.val = x;
        this.left = null;
        this.right = null;
    }

    // Constructor with value, left
    // child, and right child
    // parameters for TreeNode
    TreeNode(int x, TreeNode left, TreeNode right) {
        this.val = x;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    // Function to perform level-order
    // traversal of a binary tree
    public List<List<Integer>> levelOrder(TreeNode root) {
        // Create a list of lists to store levels
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) {
            // If the tree is empty,
            // return an empty list
            return ans;
        }

        // Create a queue to store nodes
        // for level-order traversal
        Queue<TreeNode> q = new LinkedList<>();
        // Push the root node to the queue
        q.add(root);

        while (!q.isEmpty()) {
            // Get the size of the current level
            int size = q.size();
            // Create a list to store
            // nodes at the current level
            List<Integer> level = new ArrayList<>();

            for (int i = 0; i < size; i++) {
                // Get the front node in the queue
                TreeNode node = q.poll();
                // Store the node value
                // in the current level list
                level.add(node.val);

                // Enqueue the child nodes if they exist
                if (node.left != null) {
                    q.add(node.left);
                }
                if (node.right != null) {
                    q.add(node.right);
                }
            }
            // Store the current level
            // in the answer list
            ans.add(level);
        }
        // Return the level-order
        // traversal of the tree
        return ans;
    }
}

public class Main {
    // Function to print
    // the elements of a list
    static void printList(List<Integer> list) {
        // Iterate through the
        // list and print each element
        for (int num : list) {
            System.out.print(num + "" "");
        }
        System.out.println();
    }

    // Main function
    public static void main(String[] args) {
        // Creating a sample binary tree
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);

        // Create an instance
        // of the Solution class
        Solution solution = new Solution();
        // Perform level-order traversal
        List<List<Integer>> result = solution.levelOrder(root);

        System.out.println(""Level Order Traversal of Tree:"");

        // Printing the level order traversal result
        for (List<Integer> level : result) {
            printList(level);
        }
    }
}
                            
Complexity Analysis
Time Complexity: O(N) where N is the number of nodes in the binary tree. Each node of the binary tree is enqueued and dequeued exactly once, hence all nodes need to be processed and visited. Processing each node takes constant time operations which contributes to the overall linear time complexity.

Space Complexity: O(N) where N is the number of nodes in the binary tree. In the worst case, the queue has to hold all the nodes of the last level of the binary tree, the last level could at most hold N/2 nodes hence the space complexity of the queue is proportional to O(N).The resultant vector answer also stores the values of the nodes level by level and hence contains all the nodes of the tree contributing to O(N) space as well."
Maximum depth of a Binary Tree,"Code in Java : 
                            
import java.util.LinkedList;
import java.util.Queue;

// Node class for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

class Solution {
    // Function to find the
    // maximum depth of a binary tree
    // using level order traversal
    int maxDepth(Node root) {
        // If the root is NULL
        // (empty tree), depth is 0
        if (root == null) {
            return 0;
        }

        // Create a queue for
        // level order traversal
        Queue<Node> q = new LinkedList<>();
        int level = 0;

        // Push the root node into the queue
        q.add(root);

        // While there are nodes in the queue
        while (!q.isEmpty()) {
            // Get the number of nodes
            // at the current level
            int size = q.size();

            // Process all nodes
            // at the current level
            for (int i = 0; i < size; i++) {
                // Get the front node in the queue
                Node front = q.poll();

                // Enqueue left child if exists
                if (front.left != null) {
                    q.add(front.left);
                }

                // Enqueue right child if exists
                if (front.right != null) {
                    q.add(front.right);
                }
            }
            // Increment level to
            // move to the next level
            level++;
        }
        // Return the level, which represents
        // the maximum depth of the tree
        return level;
    }
}

// Main class
public class Main {
    // Main function
    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
        root.left.right.right = new Node(6);
        root.left.right.right.right = new Node(7);

        Solution solution = new Solution();
        int depth = solution.maxDepth(root);

        System.out.println(""Maximum depth of the binary tree: "" + depth);
    }
}
                            
Complexity Analysis
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the traversal to determine the maximum depth.

Space Complexity: O(N) where N is the number of nodes in the Binary Tree because in the worst case scenario the tree is balanced and has N/2 nodes in its last level which will have to be stored in the queue."
Calculate the Diameter of a Binary Tree,"Code in Java : 
                                
// Node class for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

class Solution {
    // Function to find the
    // diameter of a binary tree
    public int diameterOfBinaryTree(Node root) {
        // Initialize the variable to
        // store the diameter of the tree
        int[] diameter = new int[1];
        diameter[0] = 0;
        // Call the height function to traverse
        // the tree and calculate diameter
        height(root, diameter);
        // Return the calculated diameter
        return diameter[0];
    }

    // Function to calculate the height of
    // the tree and update the diameter
    private int height(Node node, int[] diameter) {
        // Base case: If the node is null,
        // return 0 indicating the
        // height of an empty tree
        if (node == null) {
            return 0;
        }

        // Recursively calculate the
        // height of left and right subtrees
        int[] lh = new int[1];
        int[] rh = new int[1];
        lh[0] = height(node.left, diameter);
        rh[0] = height(node.right, diameter);

        // Update the diameter with the maximum
        // of current diameter or sum of
        // left and right heights
        diameter[0] = Math.max(diameter[0], lh[0] + rh[0]);

        // Return the height of
        // the current node's subtree
        return 1 + Math.max(lh[0], rh[0]);
    }
}

// Main class
public class Main {
    // Main function
    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
        root.left.right.right = new Node(6);
        root.left.right.right.right = new Node(7);

        // Creating an instance of the Solution class
        Solution solution = new Solution();

        // Calculate the diameter of the binary tree
        int diameter = solution.diameterOfBinaryTree(root);

        System.out.println(""The diameter of the binary tree is: "" + diameter);
    }
}                                  

                                
 Complexity Analysis
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the postorder traversal.

Space Complexity : O(1) as no additional space or data structures is created that is proportional to the input size of the tree. O(H) Recursive Stack Auxiliary Space : The recursion stack space is determined by the maximum depth of the recursion, which is the height of the binary tree denoted as H. In the balanced case it is log2N and in the worst case its N."
Check if the Binary Tree is Balanced Binary Tree,"Code in Java : 
                                
import java.lang.Math;

// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

class Solution {

    // Function to check if a binary tree is balanced
    public boolean isBalanced(Node root) {
        // Check if the tree's height difference
        // between subtrees is less than 2
        // If not, return false; otherwise, return true
        return dfsHeight(root) != -1;
    }

    // Recursive function to calculate
    // the height of the tree
    public int dfsHeight(Node root) {
        // Base case: if the current node is NULL,
        // return 0 (height of an empty tree)
        if (root == null) return 0;

        // Recursively calculate the
        // height of the left subtree
        int leftHeight = dfsHeight(root.left);

        // If the left subtree is unbalanced,
        // propagate the unbalance status
        if (leftHeight == -1) 
            return -1;

        // Recursively calculate the
        // height of the right subtree
        int rightHeight = dfsHeight(root.right);

        // If the right subtree is unbalanced,
        // propagate the unbalance status
        if (rightHeight == -1) 
            return -1;

        // Check if the difference in height between
        // left and right subtrees is greater than 1
        // If it's greater, the tree is unbalanced,
        // return -1 to propagate the unbalance status
        if (Math.abs(leftHeight - rightHeight) > 1)  
            return -1;

        // Return the maximum height of left and
        // right subtrees, adding 1 for the current node
        return Math.max(leftHeight, rightHeight) + 1;
    }
}

public class Main {
    // Main function
    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
        root.left.right.right = new Node(6);
        root.left.right.right.right = new Node(7);

        // Creating an instance of the Solution class
        Solution solution = new Solution();

        // Checking if the tree is balanced
        if (solution.isBalanced(root)) {
            System.out.println(""The tree is balanced."");
        } else {
            System.out.println(""The tree is not balanced."");
        }
    }
}                                   

                                
 Complexity Analysis
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the postorder traversal.

Space Complexity : O(1) as no additional space or data structures is created that is proportional to the input size of the tree. O(H) Recursive Stack Auxiliary Space : The recursion stack space is determined by the maximum depth of the recursion, which is the height of the binary tree denoted as H. In the balanced case it is log2N and in the worst case its N."
"Check if two trees are identical : Given two Binary Trees, return if true if the two trees are identical, otherwise return false.","Code in Java : 
                            
// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    public Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to check if two
    // binary trees are identical
    public boolean isIdentical(Node node1, Node node2) {
        // If both nodes are NULL,
        // they are identical
        if (node1 == null && node2 == null) {
            return true;
        }
        // If only one of the nodes is
        // NULL, they are not identical
        if (node1 == null || node2 == null) {
            return false;
        }
        // Check if the current nodes
        // have the same data value
        // and recursively check their
        // left and right subtrees
        return ((node1.data == node2.data)
                && isIdentical(node1.left, node2.left)
                && isIdentical(node1.right, node2.right));
    }

    public static void main(String[] args) {
        // Node1
        Node root1 = new Node(1);
        root1.left = new Node(2);
        root1.right = new Node(3);
        root1.left.left = new Node(4);

        // Node2
        Node root2 = new Node(1);
        root2.left = new Node(2);
        root2.right = new Node(3);
        root2.left.left = new Node(4);

        Solution solution = new Solution();

        if (solution.isIdentical(root1, root2)) {
            System.out.println(""The binary trees are identical."");
        } else {
            System.out.println(""The binary trees are not identical."");
        }
    }
}
                            
Complexity anlysis : 
Time Complexity: O(N+M) where N is the number of nodes in the first Binary Tree and M is the number of nodes in the second Binary Tree. This complexity arises from visiting each node of the two binary nodes during their comparison.

Space Complexity: O(1) as no additional space or data structures is created that is proportional to the input size of the tree. O(H) Recursive Stack Auxiliary Space : The recursion stack space is determined by the maximum depth of the recursion, which is the height of the binary tree denoted as H. In the balanced case it is log2N and in the worst case (its N)."
Zig Zag Traversal Of Binary Tree,"Code in Java : 
                            
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

class Solution {
    // Function to perform zigzag level
    // order traversal of a binary tree
    public List<List<Integer>> ZigZagLevelOrder(Node root) {
        // List to store the
        // result of zigzag traversal
        List<List<Integer>> result = new ArrayList<>();

        // Check if the root is null,
        // return an empty result
        if (root == null) {
            return result;
        }

        // Queue to perform
        // level order traversal
        Queue<Node> nodesQueue = new LinkedList<>();
        nodesQueue.add(root);

        // Flag to determine the direction of
        // traversal (left to right or right to left)
        boolean leftToRight = true;

        // Continue traversal until
        // the queue is empty
        while (!nodesQueue.isEmpty()) {
            // Get the number of nodes
            // at the current level
            int size = nodesQueue.size();

            // List to store the values
            // of nodes at the current level
            List<Integer> row = new ArrayList<>();

            // Traverse nodes at 
            // the current level
            for (int i = 0; i < size; i++) {
                // Get the front node
                // from the queue
                Node node = nodesQueue.poll();

                // Determine the index to insert the node's
                // value based on the traversal direction
                int index = leftToRight ? i : (size - 1 - i);

                // Insert the node's value at
                // the determined index
                row.add(index, node.data);

                // Enqueue the left and right
                // children if they exist
                if (node.left != null) {
                    nodesQueue.add(node.left);
                }
                if (node.right != null) {
                    nodesQueue.add(node.right);
                }
            }

            // Switch the traversal
            // direction for the next level
            leftToRight = !leftToRight;

            // Add the current level's
            // values to the result list
            result.add(row);
        }

        // Return the final result of
        // zigzag level order traversal
        return result;
    }
}

// Helper function to print the result
class Main {
    static void printResult(List<List<Integer>> result) {
        for (List<Integer> row : result) {
            for (int val : row) {
                System.out.print(val + "" "");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
        root.right.left = new Node(6);
        root.right.right = new Node(7);

        Solution solution = new Solution();

        // Get the zigzag level order traversal
        List<List<Integer>> result = solution.ZigZagLevelOrder(root);

        // Print the result
        printResult(result);
    }
}
 Complexity analysis : 
Time Complexity: O(N) where N is the number of nodes in the binary tree. Each node of the binary tree is enqueued and dequeued exactly once, hence all nodes need to be processed and visited. Processing each node takes constant time operations which contributes to the overall linear time complexity.

Space Complexity: O(N) where N is the number of nodes in the binary tree. In the worst case, the queue has to hold all the nodes of the last level of the binary tree, the last level could at most hold N/2 nodes hence the space complexity of the queue is proportional to O(N). The resultant vector answer also stores the values of the nodes level by level and hence contains all the nodes of the tree contributing to O(N) space as well.                          
                        "
Boundary Traversal of a Binary Tree,"The boundary traversal is the process of visiting the boundary nodes of the binary tree in the anticlockwise direction, starting from the root.
Code in Java : 
                            
import java.util.ArrayList;
import java.util.List;

// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to check
    // if a node is a leaf
    boolean isLeaf(Node root) {
        return root.left == null && root.right == null;
    }

    // Function to add the
    // left boundary of the tree
    void addLeftBoundary(Node root, List<Integer> res) {
        Node curr = root.left;
        while (curr != null) {
            // If the current node is not a leaf,
            // add its value to the result
            if (!isLeaf(curr)) {
                res.add(curr.data);
            }
            // Move to the left child if it exists,
            // otherwise move to the right child
            if (curr.left != null) {
                curr = curr.left;
            } else {
                curr = curr.right;
            }
        }
    }

    // Function to add the
    // right boundary of the tree
    void addRightBoundary(Node root, List<Integer> res) {
        Node curr = root.right;
        List<Integer> temp = new ArrayList<>();
        while (curr != null) {
            // If the current node is not a leaf,
            // add its value to a temporary list
            if (!isLeaf(curr)) {
                temp.add(curr.data);
            }
            // Move to the right child if it exists,
            // otherwise move to the left child
            if (curr.right != null) {
                curr = curr.right;
            } else {
                curr = curr.left;
            }
        }
        // Reverse and add the values from
        // the temporary list to the result
        for (int i = temp.size() - 1; i >= 0; --i) {
            res.add(temp.get(i));
        }
    }

    // Function to add the
    // leaves of the tree
    void addLeaves(Node root, List<Integer> res) {
        // If the current node is a
        // leaf, add its value to the result
        if (isLeaf(root)) {
            res.add(root.data);
            return;
        }
        // Recursively add leaves of
        // the left and right subtrees
        if (root.left != null) {
            addLeaves(root.left, res);
        }
        if (root.right != null) {
            addLeaves(root.right, res);
        }
    }

    // Main function to perform the
    // boundary traversal of the binary tree
    List<Integer> printBoundary(Node root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }
        // If the root is not a leaf,
        // add its value to the result
        if (!isLeaf(root)) {
            res.add(root.data);
        }

        // Add the left boundary, leaves,
        // and right boundary in order
        addLeftBoundary(root, res);
        addLeaves(root, res);
        addRightBoundary(root, res);

        return res;
    }

    // Helper function to
    // print the result
    void printResult(List<Integer> result) {
        for (int val : result) {
            System.out.print(val + "" "");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
        root.right.left = new Node(6);
        root.right.right = new Node(7);

        Solution solution = new Solution();

        // Get the boundary traversal
        List<Integer> result = solution.printBoundary(root);

        // Print the result
        System.out.print(""Boundary Traversal: "");
        solution.printResult(result);
    }
}
Complexity Analysis
Time Complexity: O(N) where N is the number of nodes in the Binary Tree.

Adding the left boundary of the Binary Tree results in the traversal of the left side of the tree which is proportional to the the height of the three hence O(H) ie. O(log2N). In the worst case that the tree is skewed the complexity would be O(N).
For the bottom traversal of the Binary Tree, traversing the leaves is proportional to O(N) as preorder traversal visits every node once.
Adding the right boundary of the Binary Tree results in the traversal of the right side of the tree which is proportional to the the height of the three hence O(H) ie. O(log2N). In the worst case that the tree is skewed the complexity would be O(N).
Since all these operations are performed sequentially, the overall time complexity is dominated by the most expensive operation, which is O(N).
Space Complexity: O(N) where N is the number of nodes in the Binary Tree to store the boundary nodes of the tree. O(H) or O(log2N) Recursive stack space while traversing the tree. In the worst case scenario the tree is skewed and the auxiliary recursion stack space would be stacked up to the maximum depth of the tree, resulting in an O(N) auxiliary space complexity.                            
                        "
"Given a Binary Tree, determine the maximum sum achievable along any path within the tree. ","Code in Java : 
                            
// Importing necessary packages
import java.util.*;

// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class Solution {
    // Recursive function to find the maximum path sum
    // for a given subtree rooted at 'root'
    // The variable 'maxi' is a reference parameter
    // updated to store the maximum path sum encountered
    int findMaxPathSum(Node root, int[] maxi) {
        // Base case: If the current node is null, return 0
        if (root == null) {
            return 0;
        }

        // Calculate the maximum path sum
        // for the left and right subtrees
        int leftMaxPath = Math.max(0, findMaxPathSum(root.left, maxi));
        int rightMaxPath = Math.max(0, findMaxPathSum(root.right, maxi));

        // Update the overall maximum
        // path sum including the current node
        maxi[0] = Math.max(maxi[0], leftMaxPath + rightMaxPath + root.data);

        // Return the maximum sum considering
        // only one branch (either left or right)
        // along with the current node
        return Math.max(leftMaxPath, rightMaxPath) + root.data;
    }

    // Function to find the maximum
    // path sum for the entire binary tree
    int maxPathSum(Node root) {
        // Initialize maxi to the
        // minimum possible integer value
        int[] maxi = {Integer.MIN_VALUE};

        // Call the recursive function to
        // find the maximum path sum
        findMaxPathSum(root, maxi);

        // Return the final maximum path sum
        return maxi[0];
    }

    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(3);
        root.left.left = new Node(4);
        root.left.right = new Node(5);
        root.left.right.right = new Node(6);
        root.left.right.right.right = new Node(7);

        // Creating an instance of the Solution class
        Solution solution = new Solution();

        // Finding and printing the maximum path sum
        int maxPathSum = solution.maxPathSum(root);
        System.out.println(""Maximum Path Sum: "" + maxPathSum);
    }
}
                            
Complexity analysis : 

Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the recursive traversal.

Space Complexity: O(1) as no additional space or data structures is created that is proportional to the input size of the tree. O(H) Recursive Stack Auxiliary Space : The recursion stack space is determined by the maximum depth of the recursion, which is the height of the binary tree denoted as H. In the balanced case it is log2N and in the worst case its N."
Construct A Binary Tree from Inorder and Preorder Traversal,"Code in java : 
                            
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;

// TreeNode structure
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int x) {
        val = x;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to build a binary tree
    // from preorder and inorder traversals
    public TreeNode buildTree(Vector<Integer> preorder, Vector<Integer> inorder) {
        // Create a map to store indices
        // of elements in the inorder traversal
        Map<Integer, Integer> inMap = new HashMap<>();

        // Populate the map with indices
        // of elements in the inorder traversal
        for (int i = 0; i < inorder.size(); i++) {
            inMap.put(inorder.get(i), i);
        }

        // Call the private helper function
        // to recursively build the tree
        TreeNode root = buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, inMap);

        return root;
    }

    // Recursive helper function to build the tree
    private TreeNode buildTree(Vector<Integer> preorder, int preStart, int preEnd,
            Vector<Integer> inorder, int inStart, int inEnd, Map<Integer, Integer> inMap) {
        // Base case: If the start indices
        // exceed the end indices, return null
        if (preStart > preEnd || inStart > inEnd) {
            return null;
        }

        // Create a new TreeNode with value
        // at the current preorder index
        TreeNode root = new TreeNode(preorder.get(preStart));

        // Find the index of the current root
        // value in the inorder traversal
        int inRoot = inMap.get(root.val);

        // Calculate the number of
        // elements in the left subtree
        int numsLeft = inRoot - inStart;

        // Recursively build the left subtree
        root.left = buildTree(preorder, preStart + 1, preStart + numsLeft,
                inorder, inStart, inRoot - 1, inMap);

        // Recursively build the right subtree
        root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd,
                inorder, inRoot + 1, inEnd, inMap);

        // Return the current root node
        return root;
    }

    // Function to print the
    // inorder traversal of a tree
    private void printInorder(TreeNode root) {
        if (root != null) {
            printInorder(root.left);
            System.out.print(root.val + "" "");
            printInorder(root.right);
        }
    }

    // Function to print the
    // given vector
    private void printVector(Vector<Integer> vec) {
        for (int i = 0; i < vec.size(); i++) {
            System.out.print(vec.get(i) + "" "");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Vector<Integer> inorder = new Vector<>(java.util.Arrays.asList(9, 3, 15, 20, 7));
        Vector<Integer> preorder = new Vector<>(java.util.Arrays.asList(3, 9, 20, 15, 7));

        System.out.print(""Inorder Vector: "");
        new Solution().printVector(inorder);

        System.out.print(""Preorder Vector: "");
        new Solution().printVector(preorder);

        Solution sol = new Solution();
        TreeNode root = sol.buildTree(preorder, inorder);

        System.out.println(""Inorder of Unique Binary Tree Created:"");
        sol.printInorder(root);
        System.out.println();
    }
}
                            
 Complexity analysis : 
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This is because each node of the Binary Tree is visited once.

Space Complexity: O(N) where N is the number of nodes in the Binary Tree. The inorder hashmap to store the inorder array for fast lookup takes up space proportional to the input nodes. An auxiliary stack space ~ O(H) where H is the height of the Binary Tree is used. This is the stack space used to build the tree recursively. In the case of a skewed tree, the height of the tree will be H ~ N hence the worst case auxiliary space is O(N)."
"Given a Binary Tree, determine whether the given tree is symmetric or not. ","A Binary Tree would be Symmetric, when its mirror image is exactly the same as the original tree. If we were to draw a vertical line through the centre of the tree, the nodes on the left and right side would be mirror images of each other.
Code in Java : 
                            
import java.util.*;

// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    public Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

class Solution {
    // Function to check if
    // two subtrees are symmetric
    private boolean isSymmetricUtil(Node root1, Node root2) {
        // Check if either subtree is null
        if (root1 == null || root2 == null) {
            // If one subtree is null, the other
            // must also be null for symmetry
            return root1 == root2;
        }
        // Check if the data in the current nodes is equal
        // and recursively check for symmetry in subtrees
        return (root1.data == root2.data)
                && isSymmetricUtil(root1.left, root2.right)
                && isSymmetricUtil(root1.right, root2.left);
    }

    // Public function to check if the
    // entire binary tree is symmetric
    public boolean isSymmetric(Node root) {
        // Check if the tree is empty
        if (root == null) {
            // An empty tree is
            // considered symmetric
            return true;
        }
        // Call the utility function
        // to check symmetry of subtrees
        return isSymmetricUtil(root.left, root.right);
    }
}

public class Main {
    // Function to print the Inorder
    // Traversal of the Binary Tree
    private static void printInorder(Node root) {
        if (root == null) {
            return;
        }
        printInorder(root.left);
        System.out.print(root.data + "" "");
        printInorder(root.right);
    }

    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.right = new Node(2);
        root.left.left = new Node(3);
        root.right.right = new Node(3);
        root.left.right = new Node(4);
        root.right.left = new Node(4);

        Solution solution = new Solution();

        System.out.print(""Binary Tree (Inorder): "");
        printInorder(root);
        System.out.println();

        boolean res = solution.isSymmetric(root);

        if (res) {
            System.out.println(""This Tree is Symmetrical"");
        } else {
            System.out.println(""This Tree is NOT Symmetrical"");
        }
    }
}
  Complexity Analysis
Time Complexity: O(N) where N is the number of nodes in the Binary Tree. This is because each node of the Binary Tree is visited once.

Space Complexity: O(N) where N is the number of nodes in the Binary Tree. The inorder hashmap to store the inorder array for fast lookup takes up space proportional to the input nodes. An auxiliary stack space ~ O(H) where H is the height of the Binary Tree is used. This is the stack space used to build the tree recursively. In the case of a skewed tree, the height of the tree will be H ~ N hence the worst case auxiliary space is O(N).                          
                        "
Flatten Binary Tree to Linked List,"Code in Java : 
import java.util.*;

class Node {
  int data;
  Node  left, right;
  Node(int data)
  {
      this.data=data;
      left=null;
      right=null;
  }
}

public class Solution {
  static Node prev = null;
    static void flatten(Node root) {
        Node cur = root;
		while (cur!=null)
		{
			if(cur.left!=null)
			{
				Node pre = cur.left;
				while(pre.right!=null)
				{
					pre = pre.right;
				}
				pre.right = cur.right;
				cur.right = cur.left;
				cur.left = null;
			}
			cur = cur.right;
		}
    }




public static void main(String args[]) {

  Node  root = new Node(1);
  root . left = new Node(2);
  root . left . left = new Node(3);
  root . left . right = new Node(4);
  root . right = new Node(5);
  root . right . right = new Node(6);
  root . right . right . left = new Node(7);
  flatten(root);
  while(root.right!=null)
  {
      System.out.print(root.data+""->"");
      root=root.right;
  }
System.out.print(root.data);
}
}
Complexity analysis : 
Time Complexity: O(N)

Reason: Time complexity will be the same as that of a morris traversal

Space Complexity: O(1)

Reason: We are not using any extra space."
"Check for Children Sum Property in a Binary Tree : Given a Binary Tree, convert the value of its nodes to follow the Children Sum Property.","The Children Sum Property in a binary tree states that for every node, the sum of its children's values (if they exist) should be equal to the node's value. If a child is missing, it is considered as having a value of 0.
Code in Java : 
                            
import java.util.LinkedList;
import java.util.Queue;

// TreeNode structure
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int x) {
        val = x;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to change the values of the nodes
    // based on the sum of its children's values.
    public void changeTree(TreeNode root) {
        // Base case: If the current node
        // is null, return and do nothing.
        if (root == null) {
            return;
        }

        // Calculate the sum of the values of
        // the left and right children, if they exist.
        int child = 0;
        if (root.left != null) {
            child += root.left.val;
        }
        if (root.right != null) {
            child += root.right.val;
        }

        // Compare the sum of children with
        // the current node's value and update
        if (child >= root.val) {
            root.val = child;
        } else {
            // If the sum is smaller, update the
            // child with the current node's value.
            if (root.left != null) {
                root.left.val = root.val;
            } else if (root.right != null) {
                root.right.val = root.val;
            }
        }

        // Recursively call the function
        // on the left and right children.
        changeTree(root.left);
        changeTree(root.right);

        // Calculate the total sum of the
        // values of the left and right
        // children, if they exist.
        int tot = 0;
        if (root.left != null) {
            tot += root.left.val;
        }
        if (root.right != null) {
            tot += root.right.val;
        }

        // If either left or right child
        // exists, update the current node's
        // value with the total sum.
        if (root.left != null || root.right != null) {
            root.val = tot;
        }
    }
}

// Function to print the inorder
// traversal of the tree
class TreeTraversal {
    public static void inorderTraversal(TreeNode root) {
        if (root == null) {
            return;
        }
        inorderTraversal(root.left);
        System.out.print(root.val + "" "");
        inorderTraversal(root.right);
    }
}

class Main {
    public static void main(String[] args) {
        // Create the binary tree
        TreeNode root = new TreeNode(3);
        root.left = new TreeNode(5);
        root.right = new TreeNode(1);
        root.left.left = new TreeNode(6);
        root.left.right = new TreeNode(2);
        root.right.left = new TreeNode(0);
        root.right.right = new TreeNode(8);
        root.left.right.left = new TreeNode(7);
        root.left.right.right = new TreeNode(4);

        Solution sol = new Solution();

        // Print the inorder traversal
        // of tree before modification
        System.out.print(""Binary Tree before modification: "");
        TreeTraversal.inorderTraversal(root);
        System.out.println();

        // Call the changeTree function
        // to modify the binary tree
        sol.changeTree(root);

        // Print the inorder traversal
        // after modification
        System.out.print(""Binary Tree after Children Sum Property: "");
        TreeTraversal.inorderTraversal(root);
        System.out.println();
    }
}
                            
 Time Complexity: O(N) where N is the number of nodes in the binary tree. This is because the algorithm traverses each node exactly once, performing constant-time operations at each node.

Space Complexity: O(N) where N is the number of nodes in the Binary Tree.

In the worst case scenario the tree is skewed and the auxiliary recursion stack space would be stacked up to the maximum height of the tree, resulting in a space complexity of O(N).
In the optimal case of a balanced tree, the auxiliary space would take up space proportional to O(log2N).                     "
A program to check if a Binary Tree is (Binary Search Tree ) BST or not,"Approach : Using morris traversal
Code in Java : 
// Java code to implement the morris traversal approach

class TreeNode {
	int val;
	TreeNode left;
	TreeNode right;

	TreeNode(int x)
	{
		val = x;
		left = null;
		right = null;
	}
}

class solution{
	public static boolean isValidBST(TreeNode root)
	{
		TreeNode curr = root;
		TreeNode prev = null;

		while (curr != null) {
			if (curr.left
				== null) { // case 1: no left child
				// process the current node
				if (prev != null && prev.val >= curr.val)
					return false;
				prev = curr;
				curr = curr.right;
			}
			else { // case 2: has a left child
				// find the inorder predecessor
				TreeNode pred = curr.left;
				while (pred.right != null
					&& pred.right != curr)
					pred = pred.right;

				if (pred.right
					== null) { // make threaded link
					pred.right = curr;
					curr = curr.left;
				}
				else { // remove threaded link
					pred.right = null;
					// process the current node
					if (prev != null
						&& prev.val >= curr.val)
						return false;
					prev = curr;
					curr = curr.right;
				}
			}
		}

		return true; // binary tree is a valid BST
	}

	public static void main(String[] args)
	{
		// create the binary tree from the example
		TreeNode root = new TreeNode(4);
		root.left = new TreeNode(2);
		root.right = new TreeNode(5);
		root.left.left = new TreeNode(1);
		root.left.right = new TreeNode(3);

		// check if the binary tree is a valid BST
		if (isValidBST(root))
			System.out.println(
				""The binary tree is a valid BST."");
		else
			System.out.println(
				""The binary tree is not a valid BST."");
	}
}

Complexity analysis : 
Time Complexity: O(N), Where N is the number of nodes in the tree.
Space Complexity: O(1) , Because we are not using any addition data structure or recursive call stack."
Searching in Binary Search Tree (BST),"Approach : For searching a value in BST, consider it as a sorted array. Now we can easily perform search operation in BST using Binary Search Algorithm.  
Code in Java : 
class Node {
        int key;
        Node left, right;

        public Node(int item) {
                key = item;
                left = right = null;
        }
}

class BinarySearchTree {
        Node root;

        // Constructor
        BinarySearchTree() {
                root = null;
        }

        // A utility function to insert
        // a new node with given key in BST
        Node insert(Node node, int key) {
                // If the tree is empty, return a new node
                if (node == null) {
                        node = new Node(key);
                        return node;
                }

                // Otherwise, recur down the tree
                if (key < node.key)
                        node.left = insert(node.left, key);
                else if (key > node.key)
                        node.right = insert(node.right, key);

                // Return the (unchanged) node pointer
                return node;
        }

        // Utility function to search a key in a BST
        Node search(Node root, int key) {
                // Base Cases: root is null or key is present at root
                if (root == null || root.key == key)
                        return root;

                // Key is greater than root's key
                if (root.key < key)
                        return search(root.right, key);

                // Key is smaller than root's key
                return search(root.left, key);
        }

        // Driver Code
        public static void main(String[] args) {
                BinarySearchTree tree = new BinarySearchTree();

                // Inserting nodes
                tree.root = tree.insert(tree.root, 50);
                tree.insert(tree.root, 30);
                tree.insert(tree.root, 20);
                tree.insert(tree.root, 40);
                tree.insert(tree.root, 70);
                tree.insert(tree.root, 60);
                tree.insert(tree.root, 80);

                // Key to be found
                int key = 6;

                // Searching in a BST
                if (tree.search(tree.root, key) == null)
                        System.out.println(key + "" not found"");
                else
                        System.out.println(key + "" found"");

                key = 60;

                // Searching in a BST
                if (tree.search(tree.root, key) == null)
                        System.out.println(key + "" not found"");
                else
                        System.out.println(key + "" found"");
        }
}
Complexity analysis : 
Time complexity: O(h), where h is the height of the BST.
Space complexity: O(h), where h is the height of the BST. This is because the maximum amount of space needed to store the recursion stack would be h."
"Insertion in Binary Search Tree (BST) : Given a BST, the task is to insert a new node in this BST.","Approach :  Using recursion
Code in Java : 
import java.io.*;

public class BinarySearchTree {

	// Class containing left
	// and right child of current node
	// and key value
	class Node {
		int key;
		Node left, right;

		public Node(int item)
		{
			key = item;
			left = right = null;
		}
	}

	// Root of BST
	Node root;

	// Constructor
	BinarySearchTree() { root = null; }

	BinarySearchTree(int value) { root = new Node(value); }

	// This method mainly calls insertRec()
	void insert(int key) { root = insertRec(root, key); }

	// A recursive function to
	// insert a new key in BST
	Node insertRec(Node root, int key)
	{
		// If the tree is empty,
		// return a new node
		if (root == null) {
			root = new Node(key);
			return root;
		}

		// Otherwise, recur down the tree
		else if (key < root.key)
			root.left = insertRec(root.left, key);
		else if (key > root.key)
			root.right = insertRec(root.right, key);

		// Return the (unchanged) node pointer
		return root;
	}

	// This method mainly calls InorderRec()
	void inorder() { inorderRec(root); }

	// A utility function to
	// do inorder traversal of BST
	void inorderRec(Node root)
	{
		if (root != null) {
			inorderRec(root.left);
			System.out.print(root.key + "" "");
			inorderRec(root.right);
		}
	}

	// Driver Code
	public static void main(String[] args)
	{
		BinarySearchTree tree = new BinarySearchTree();

		/* Let us create following BST
			50
		/	 \
		30	 70
		/ \ / \
	20 40 60 80 */
		tree.insert(50);
		tree.insert(30);
		tree.insert(20);
		tree.insert(40);
		tree.insert(70);
		tree.insert(60);
		tree.insert(80);

		// Print inorder traversal of the BST
		tree.inorder();
	}
}

Time Complexity: 

The worst-case time complexity of insert operations is O(h) where h is the height of the Binary Search Tree. 
In the worst case, we may have to travel from the root to the deepest leaf node. The height of a skewed tree may become n and the time complexity of insertion operation may become O(n). 
Space complexity: The auxiliary space complexity of insertion into a binary search tree is O(1)
"
Deletion in Binary Search Tree (BST) : the task is to delete a node in this BST,"Deletion in Binary Tree can be broken down into three scenarios :
Case 1. Delete a Leaf Node in BST
Case 2. Delete a Node with Single Child in BST - Deleting a single child node is also simple in BST. Copy the child to the node and delete the node. 
Case 3. Delete a Node with Both Children in BST - Deleting a node with both children is not so simple. Here we have to delete the node is such a way, that the resulting tree follows the properties of a BST.  
The trick is to find the inorder successor of the node. Copy contents of the inorder successor to the node, and delete the inorder successor.
Code in Java : 
class Node {
    int key;
    Node left, right;

    Node(int item) {
        key = item;
        left = right = null;
    }
}

class BinaryTree {
    Node root;

    BinaryTree() {
        root = null;
    }

    // A utility function to insert a new node with the given key
    Node insert(Node node, int key) {
        // If the tree is empty, return a new node
        if (node == null) {
            return new Node(key);
        }

        // Otherwise, recur down the tree
        if (key < node.key) {
            node.left = insert(node.left, key);
        } else if (key > node.key) {
            node.right = insert(node.right, key);
        }

        // return the (unchanged) node pointer
        return node;
    }

    // A utility function to do inorder traversal of BST
    void inorder(Node root) {
        if (root != null) {
            inorder(root.left);
            System.out.print(root.key + "" "");
            inorder(root.right);
        }
    }

    // Given a binary search tree and a key, this function deletes the key and returns the new root
    Node deleteNode(Node root, int key) {
        // Base case
        if (root == null) {
            return root;
        }

        // If the key to be deleted is smaller than the root's key, then it lies in the left subtree
        if (key < root.key) {
            root.left = deleteNode(root.left, key);
        }
        // If the key to be deleted is greater than the root's key, then it lies in the right subtree
        else if (key > root.key) {
            root.right = deleteNode(root.right, key);
        }
        // If key is same as root's key, then this is the node to be deleted
        else {
            // Node with only one child or no child
            if (root.left == null) {
                return root.right;
            } else if (root.right == null) {
                return root.left;
            }

            // Node with two children: Get the inorder successor (smallest in the right subtree)
            root.key = minValue(root.right);

            // Delete the inorder successor
            root.right = deleteNode(root.right, root.key);
        }

        return root;
    }

    int minValue(Node root) {
        int minv = root.key;
        while (root.left != null) {
            minv = root.left.key;
            root = root.left;
        }
        return minv;
    }

    // Driver Code
    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();

        /* Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 */
        tree.root = tree.insert(tree.root, 50);
        tree.insert(tree.root, 30);
        tree.insert(tree.root, 20);
        tree.insert(tree.root, 40);
        tree.insert(tree.root, 70);
        tree.insert(tree.root, 60);
        tree.insert(tree.root, 80);

        System.out.print(""Original BST: "");
        tree.inorder(tree.root);
        System.out.println();

        System.out.println(""\nDelete a Leaf Node: 20"");
        tree.root = tree.deleteNode(tree.root, 20);
        System.out.print(""Modified BST tree after deleting Leaf Node:\n"");
        tree.inorder(tree.root);
        System.out.println();

        System.out.println(""\nDelete Node with single child: 70"");
        tree.root = tree.deleteNode(tree.root, 70);
        System.out.print(""Modified BST tree after deleting single child Node:\n"");
        tree.inorder(tree.root);
        System.out.println();

        System.out.println(""\nDelete Node with both child: 50"");
        tree.root = tree.deleteNode(tree.root, 50);
        System.out.print(""Modified BST tree after deleting both child Node:\n"");
        tree.inorder(tree.root);
    }
}
Complexity analysis : 
Time Complexity: O(h), where h is the height of the BST. 
Space Complexity: O(n)."
"Balance a Binary Search Tree : Given a BST (Binary Search Tree) that may be unbalanced, convert it into a balanced BST that has minimum possible height.","Approach : An Efficient Solution can be to construct a balanced BST in O(n) time with minimum possible height.
Code in Java : 
import java.util.*;

/* A binary tree node has data, pointer to left child
and a pointer to right child */
class Node 
{
	int data;
	Node left, right;

	public Node(int data) 
	{
		this.data = data;
		left = right = null;
	}
}

class BinaryTree 
{
	Node root;

	/* This function traverse the skewed binary tree and
	stores its nodes pointers in vector nodes[] */
	void storeBSTNodes(Node root, Vector<Node> nodes) 
	{
		// Base case
		if (root == null)
			return;

		// Store nodes in Inorder (which is sorted
		// order for BST)
		storeBSTNodes(root.left, nodes);
		nodes.add(root);
		storeBSTNodes(root.right, nodes);
	}

	/* Recursive function to construct binary tree */
	Node buildTreeUtil(Vector<Node> nodes, int start,
			int end) 
	{
		// base case
		if (start > end)
			return null;

		/* Get the middle element and make it root */
		int mid = (start + end) / 2;
		Node node = nodes.get(mid);

		/* Using index in Inorder traversal, construct
		left and right subtress */
		node.left = buildTreeUtil(nodes, start, mid - 1);
		node.right = buildTreeUtil(nodes, mid + 1, end);

		return node;
	}

	// This functions converts an unbalanced BST to
	// a balanced BST
	Node buildTree(Node root) 
	{
		// Store nodes of given BST in sorted order
		Vector<Node> nodes = new Vector<Node>();
		storeBSTNodes(root, nodes);

		// Constructs BST from nodes[]
		int n = nodes.size();
		return buildTreeUtil(nodes, 0, n - 1);
	}

	/* Function to do preorder traversal of tree */
	void preOrder(Node node) 
	{
		if (node == null)
			return;
		System.out.print(node.data + "" "");
		preOrder(node.left);
		preOrder(node.right);
	}

	// Driver program to test the above functions
	public static void main(String[] args) 
	{
		/* Constructed skewed binary tree is
				10
			/
			8
			/
			7
		/
		6
		/
		5 */
		BinaryTree tree = new BinaryTree();
		tree.root = new Node(10);
		tree.root.left = new Node(8);
		tree.root.left.left = new Node(7);
		tree.root.left.left.left = new Node(6);
		tree.root.left.left.left.left = new Node(5);

		tree.root = tree.buildTree(tree.root);
		System.out.println(""Preorder traversal of balanced BST is :"");
		tree.preOrder(tree.root);
	}
}

Complexity analysis : 
Time Complexity: O(n), As we are just traversing the tree twice. Once in inorder traversal and then in construction of the balanced tree.
Auxiliary space: O(n), The extra space is used to store the nodes of the inorder traversal in the vector. Also the extra space taken by recursion call stack is O(h) where h is the height of the tree.
"
"Count BST nodes that lie in a given range : Given the head of a Binary Search Tree (BST) and a range (l, h), count the number of nodes that lie in the given range (l, h).","Approach:Traverse the given binary search tree starting from root. For every node check if this node lies in range, if yes, then add 1 to result and recur for both of its children. If current node is smaller than low value of range, then recur for right child, else recur for left child.
Code in Java : 
class BinarySearchTree {

	/* Class containing left and right child
	of current node and key value*/
	static class Node {
		int data;
		Node left, right;

		public Node(int item) {
			data = item;
			left = right = null;
		}
	}

	// Root of BST
	Node root;

	// Constructor
	BinarySearchTree() { 
		root = null; 
	}
	
	// Returns count of nodes in BST in 
	// range [low, high]
	int getCount(Node node, int low, int high)
	{
		// Base Case
		if(node == null)
			return 0;

		// If current node is in range, then 
		// include it in count and recur for 
		// left and right children of it
		if(node.data >= low && node.data <= high)
			return 1 + this.getCount(node.left, low, high)+
				this.getCount(node.right, low, high);
				
		// If current node is smaller than low, 
		// then recur for right child
		else if(node.data < low)
			return this.getCount(node.right, low, high);
		
		// Else recur for left child
		else
			return this.getCount(node.left, low, high);	 
	}

	// Driver function
	public static void main(String[] args) {
		BinarySearchTree tree = new BinarySearchTree();
		
		tree.root = new Node(10);
		tree.root.left	 = new Node(5);
		tree.root.right	 = new Node(50);
		tree.root.left.left = new Node(1);
		tree.root.right.left = new Node(40);
		tree.root.right.right = new Node(100);
		/* Let us constructed BST shown in above example
		10
		/ \
	5	 50
	/	 / \
	1	 40 100 */
	int l=5;
	int h=45;
	System.out.println(""Count of nodes between ["" + l + "", ""
					+ h+ ""] is "" + tree.getCount(tree.root,
												l, h));
	}
}

"
Convert BST to Max Heap :. The problem is to convert a given BST into a Special Max Heap with the condition that all the values in the left subtree of a node should be less than all the values in the right subtree of the node. ,"Approach : Using Max Heap
Code in Java : 
import java.io.*;
import java.util.*;

// Defining the structure of the Node class
class Node {
        int data;
        Node left, right;
        Node(int data)
        {
                this.data = data;
                left = right = null;
        }
}

class solution {

        // Function to find the parent index of a node
        static int parent(int i) { return (i - 1) / 2; }

        // Function to heapify up the node to arrange in
        // max-heap order
        static void heapify_up(List<Node> q, int i)
        {
                while (i > 0
                        && q.get(parent(i)).data < q.get(i).data) {
                        Collections.swap(q, i, parent(i));
                        i = parent(i);
                }
        }

        // Function to convert BST to max heap
        static Node convertToMaxHeapUtil(Node root)
        {
                if (root == null) {
                        return root;
                }
                // Creating a list for storing the nodes of BST
                List<Node> q = new ArrayList<Node>();
                q.add(root);
                int i = 0;
                while (q.size() != i) {
                        if (q.get(i).left != null) {
                                q.add(q.get(i).left);
                        }
                        if (q.get(i).right != null) {
                                q.add(q.get(i).right);
                        }
                        i++;
                }

                // Calling heapify_up for each node in the list
                for (int j = 1; j < q.size(); j++) {
                        heapify_up(q, j);
                }

                // Updating the root as the maximum value in heap
                root = q.get(0);
                i = 0;

                // Updating left and right nodes of BST using list
                while (i < q.size()) {
                        if (2 * i + 1 < q.size()) {
                                q.get(i).left = q.get(2 * i + 1);
                        }
                        else {
                                q.get(i).left = null;
                        }
                        if (2 * i + 2 < q.size()) {
                                q.get(i).right = q.get(2 * i + 2);
                        }
                        else {
                                q.get(i).right = null;
                        }
                        i++;
                }
                return root;
        }

        // Function to print postorder traversal of the tree
        static void postorderTraversal(Node root)
        {
                if (root == null) {
                        return;
                }
                // Recurring on left subtree
                postorderTraversal(root.left);
                // Recurring on right subtree
                postorderTraversal(root.right);

                // Printing the root's data
                System.out.print(root.data + "" "");
        }

        public static void main(String[] args)
        {
                // Creating the BST
                Node root = new Node(4);
                root.left = new Node(2);
                root.right = new Node(6);
                root.left.left = new Node(1);
                root.left.right = new Node(3);
                root.right.left = new Node(5);
                root.right.right = new Node(7);
                // Converting the BST to max heap
                root = convertToMaxHeapUtil(root);

                // Printing the postorder traversal of the tree
                System.out.println(""Postorder Traversal of Tree: "");
                postorderTraversal(root);
        }
}
Complexity analysis : 
Time Complexity: O(n) 
Space Complexity: O(n)
"
Reverse Words in a String,"Code in Java : 
import java.io.*;
class Test
{
static private String result(String s)
{
	int left = 0;
	int right = s.length() - 1;

	String temp = """";
	String ans = """";

	//Iterate the string and keep on adding to form a word
	//If empty space is encountered then add the current word to the result
	while (left <= right)
	{
		char ch = s.charAt(left);
		if (ch != ' ')
		{
			temp += ch;
		}
		else if (ch == ' ')
		{
			if (!ans.equals(""""))
			{
				ans = temp + "" "" + ans;
			}
			else
			{
				ans = temp;
			}
			temp = """";
		}
		left++;
	}

	//If not empty string then add to the result(Last word is added)
	if (!temp.equals(""""))
	{
		if (!ans.equals(""""))
		{
			ans = temp + "" "" + ans;
		}
		else
		{
			ans = temp;
		}
	}

	return ans;
}
public static void main(String[] args)
{
	String st = ""TUF is great for interview preparation"";
	System.out.println(""Before reversing words: "");
    System.out.println(st);
    System.out.println(""After reversing words: "");
	System.out.print(result(st));
}
}
Complexity analysis : 
Time Complexity: O(N), N~length of string

Space Complexity: O(1), Constant Space"
Depth First Search (DFS) of graph,"Code in Java : 
import java.util.*;
class Solution {
    
    public static void dfs(int node, boolean vis[], ArrayList<ArrayList<Integer>> adj, 
    ArrayList<Integer> ls) {
        
        //marking current node as visited
        vis[node] = true;
        ls.add(node);
        
        //getting neighbour nodes
        for(Integer it: adj.get(node)) {
            if(vis[it] == false) {
                dfs(it, vis, adj, ls);
            }
        }
    }
    // Function to return a list containing the DFS traversal of the graph.
    public ArrayList<Integer> dfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
        //boolean array to keep track of visited vertices
        boolean vis[] = new boolean[V+1];
        vis[0] = true; 
        ArrayList<Integer> ls = new ArrayList<>();
        dfs(0, vis, adj, ls); 
        return ls; 
    }
    
    public static void main(String args[]) {

        ArrayList < ArrayList < Integer >> adj = new ArrayList < > ();
        for (int i = 0; i < 5; i++) {
            adj.add(new ArrayList < > ());
        }
        adj.get(0).add(2);
        adj.get(2).add(0);
        adj.get(0).add(1);
        adj.get(1).add(0);
        adj.get(0).add(3);
        adj.get(3).add(0);
        adj.get(2).add(4);
        adj.get(4).add(2);
        
        Solution sl = new Solution(); 
        ArrayList < Integer > ans = sl.dfsOfGraph(5, adj);
        int n = ans.size(); 
        for(int i = 0;i<n;i++) {
            System.out.print(ans.get(i)+"" ""); 
        }
    }
}
Complexity analysis : 
Time Complexity: For an undirected graph, O(N) + O(2E), For a directed graph, O(N) + O(E), Because for every node we are calling the recursive function once, the time taken is O(N) and 2E is for total degrees as we traverse for all adjacent nodes.

Space Complexity: O(3N) ~ O(N), Space for dfs stack space, visited array and an adjacency list."
Breadth First Search (BFS): Level Order Traversal of graph,"Code in Java : 
import java.util.*;
class Solution {
    // Function to return Breadth First Traversal of given graph.
    public ArrayList<Integer> bfsOfGraph(int V, 
    ArrayList<ArrayList<Integer>> adj) {
        
        ArrayList < Integer > bfs = new ArrayList < > ();
        boolean vis[] = new boolean[V];
        Queue < Integer > q = new LinkedList < > ();

        q.add(0);
        vis[0] = true;

        while (!q.isEmpty()) {
            Integer node = q.poll();
            bfs.add(node);

            // Get all adjacent vertices of the dequeued vertex s
            // If a adjacent has not been visited, then mark it
            // visited and enqueue it
            for (Integer it: adj.get(node)) {
                if (vis[it] == false) {
                    vis[it] = true;
                    q.add(it);
                }
            }
        }

        return bfs;
    }
    
    public static void main(String args[]) {

        ArrayList < ArrayList < Integer >> adj = new ArrayList < > ();
        for (int i = 0; i < 5; i++) {
            adj.add(new ArrayList < > ());
        }
        adj.get(0).add(1);
        adj.get(1).add(0);
        adj.get(0).add(4);
        adj.get(4).add(0);
        adj.get(1).add(2);
        adj.get(2).add(1);
        adj.get(1).add(3);
        adj.get(3).add(1);
        
        Solution sl = new Solution(); 
        ArrayList < Integer > ans = sl.bfsOfGraph(5, adj);
        int n = ans.size(); 
        for(int i = 0;i<n;i++) {
            System.out.print(ans.get(i)+"" ""); 
        }
    }
}
Complexity analysis
Time Complexity: O(N) + O(2E), Where N = Nodes, 2E is for total degrees as we traverse all adjacent nodes.

Space Complexity: O(3N) ~ O(N), Space for queue data structure visited array and an adjacency list"
Detect Cycle in an Undirected Graph ,"Given an undirected graph with V vertices and E edges,to check whether it contains any cycle or not, there are two approaches : 
The cycle in a graph starts from a node and ends at the same node. So we can think of two algorithms to do this, BFS and DFS.
1.  Using BFS : Breadth First Search, BFS is a traversal technique where we visit the nodes level-wise, i.e., it visits the same level nodes simultaneously, and then moves to the next level. 

The intuition is that we start from a node, and start doing BFS level-wise, if somewhere down the line, we visit a single node twice, it means we came via two paths to end up at the same node. It implies there is a cycle in the graph because we know that we start from different directions but can arrive at the same node only if the graph is connected or contains a cycle, otherwise we would never come to the same node again.  
Code in Java : 
import java.util.*;

class Solution
{
   static boolean checkForCycle(ArrayList<ArrayList<Integer>> adj, int s,
            boolean vis[], int parent[])
    {
       Queue<Node> q =  new LinkedList<>(); //BFS
       q.add(new Node(s, -1));
       vis[s] =true;
       
       // until the queue is empty
       while(!q.isEmpty())
       {
           // source node and its parent node
           int node = q.peek().first;
           int par = q.peek().second;
           q.remove(); 
           
           // go to all the adjacent nodes
           for(Integer it: adj.get(node))
           {
               if(vis[it]==false)  
               {
                   q.add(new Node(it, node));
                   vis[it] = true; 
               }
        
                // if adjacent node is visited and is not its own parent node
               else if(par != it) return true;
           }
       }
       
       return false;
    }
    
    // function to detect cycle in an undirected graph
    public boolean isCycle(int V, ArrayList<ArrayList<Integer>> adj)
    {
        boolean vis[] = new boolean[V];
        Arrays.fill(vis,false);
        int parent[] = new int[V];
        Arrays.fill(parent,-1);  
        
        for(int i=0;i<V;i++)
            if(vis[i]==false) 
                if(checkForCycle(adj, i,vis, parent)) 
                    return true;
    
        return false;
    }
    
    public static void main(String[] args)
    {
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            adj.add(new ArrayList < > ());
        }
        adj.get(1).add(2);
        adj.get(2).add(1);
        adj.get(2).add(3);
        adj.get(3).add(2);
                
        Solution obj = new Solution();
        boolean ans = obj.isCycle(4, adj);
        if (ans)
            System.out.println(""1"");    
        else
            System.out.println(""0"");
    }
}

class Node {
    int first;
    int second;
    public Node(int first, int second) {
        this.first = first;
        this.second = second; 
    }
}
Complexity analysis : 
Time Complexity: O(N + 2E) + O(N), Where N = Nodes, 2E is for total degrees as we traverse all adjacent nodes. In the case of connected components of a graph, it will take another O(N) time.

Space Complexity: O(N) + O(N) ~ O(N), Space for queue data structure and visited array.

2. Using DFS :DFS is a traversal technique that involves the idea of recursion and backtracking. DFS goes in-depth, i.e., traverses all nodes by going ahead, and when there are no further nodes to traverse in the current path, then it backtracks on the same path and traverses other unvisited nodes. The intuition is that we start from a source and go in-depth, and reach any node that has been previously visited in the past; it means there's a cycle.
Code in Java : 
import java.util.*;

class Solution {
    private boolean dfs(int node, int parent, int vis[], ArrayList<ArrayList<Integer>> 
    adj) {
        vis[node] = 1; 
        // go to all adjacent nodes
        for(int adjacentNode: adj.get(node)) {
            if(vis[adjacentNode]==0) {
                if(dfs(adjacentNode, node, vis, adj) == true) 
                    return true; 
            }
            // if adjacent node is visited and is not its own parent node
            else if(adjacentNode != parent) return true; 
        }
        return false; 
    }
    // Function to detect cycle in an undirected graph.
    public boolean isCycle(int V, ArrayList<ArrayList<Integer>> adj) {
       int vis[] = new int[V]; 
       for(int i = 0;i<V;i++) {
           if(vis[i] == 0) {
               if(dfs(i, -1, vis, adj) == true) return true; 
           }
       }
       return false; 
    }
    public static void main(String[] args)
    {
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < 4; i++) {
            adj.add(new ArrayList < > ());
        }
        adj.get(1).add(2);
        adj.get(2).add(1);
        adj.get(2).add(3);
        adj.get(3).add(2);
                
        Solution obj = new Solution();
        boolean ans = obj.isCycle(4, adj);
        if (ans)
            System.out.println(""1"");    
        else
            System.out.println(""0"");
    }

}
Complexity analysis : 
Time Complexity: O(N + 2E) + O(N), Where N = Nodes, 2E is for total degrees as we traverse all adjacent nodes. In the case of connected components of a graph, it will take another O(N) time.

Space Complexity: O(N) + O(N) ~ O(N), Space for recursive stack space and visited array."
Detect a Cycle in Directed Graph,"Given an undirected graph with V vertices and E edges,to check whether it contains any cycle or not, there are two approaches : 
The cycle in a graph starts from a node and ends at the same node. So we can think of two algorithms to do this, DFS and BFS.
1. Using DFS : In a Directed Cyclic Graph, during traversal, if we end up at a node, which we have visited previously in the path, that means we came around a circle and ended up at this node, which determines that it has a cycle.
Code in Java : 
import java.util.*;

class Solution {
    private boolean dfsCheck(int node, ArrayList<ArrayList<Integer>> adj, int vis[], int pathVis[]) {
        vis[node] = 1; 
        pathVis[node] = 1; 
        
        // traverse for adjacent nodes 
        for(int it : adj.get(node)) {
            // when the node is not visited 
            if(vis[it] == 0) {
                if(dfsCheck(it, adj, vis, pathVis) == true) 
                    return true; 
            }
            // if the node has been previously visited
            // but it has to be visited on the same path 
            else if(pathVis[it] == 1) {
                return true; 
            }
        }
        
        pathVis[node] = 0; 
        return false; 
    }

    // Function to detect cycle in a directed graph.
    public boolean isCyclic(int V, ArrayList<ArrayList<Integer>> adj) {
        int vis[] = new int[V];
        int pathVis[] = new int[V];
        
        for(int i = 0;i<V;i++) {
            if(vis[i] == 0) {
                if(dfsCheck(i, adj, vis, pathVis) == true) return true; 
            }
        }
        return false; 
    }
}

public class driver {
    public static void main(String[] args) {
        int V = 11;
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<>());
        }
        adj.get(1).add(2);
        adj.get(2).add(3);
        adj.get(3).add(4);
        adj.get(3).add(7);
        adj.get(4).add(5);
        adj.get(5).add(6);
        adj.get(7).add(5);
        adj.get(8).add(9);
        adj.get(9).add(10);
        adj.get(10).add(8);

        Solution obj = new Solution();
        boolean ans = obj.isCyclic(V, adj);
        if (ans)
            System.out.println(""True"");
        else
            System.out.println(""False"");

    }
}
Complexity analysis : 
Time Complexity: O(V+E)+O(V) , where V = no. of nodes and E = no. of edges. There can be at most V components. So, another O(V) time complexity.

Space Complexity: O(2N) + O(N) ~ O(2N): O(2N) for two visited arrays and O(N) for recursive stack space.

2. Using BFS : Topological sorting is only possible for directed acyclic graphs(DAGs) if we apply Kahn’s algorithm in a directed cyclic graph(A directed graph that contains a cycle), it will fail to find the topological sorting(i.e. The final sorting will not contain all the nodes or vertices). 
Code in Java : 
import java.util.*;

class Solution {
    public boolean isCyclic(int N, ArrayList<ArrayList<Integer>> adj) {
        // int topo[] = new int[N];
        int indegree[] = new int[N];
        for (int i = 0; i < N; i++) {
            for (Integer it : adj.get(i)) {
                indegree[it]++;
            }
        }

        Queue<Integer> q = new LinkedList<Integer>();
        for (int i = 0; i < N; i++) {
            if (indegree[i] == 0) {
                q.add(i);
            }
        }
        int cnt = 0;
        while (!q.isEmpty()) {
            Integer node = q.poll();
            cnt++;
            for (Integer it : adj.get(node)) {
                indegree[it]--;
                if (indegree[it] == 0) {
                    q.add(it);
                }
            }
        }
        if (cnt == N)
            return false;
        return true;
    }
}

public class driver {
    public static void main(String[] args) {
        int V = 6;
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<>());
        }
        adj.get(1).add(2);
        adj.get(2).add(3);
        adj.get(3).add(4);
        adj.get(3).add(5);
        adj.get(4).add(2);

        Solution obj = new Solution();
        boolean ans = obj.isCyclic(V, adj);
        if (ans)
            System.out.println(""True"");
        else
            System.out.println(""False"");
    }
}
Complexity analysis:
Time Complexity: O(V+E), where V = no. of nodes and E = no. of edges. This is a simple BFS algorithm.

Space Complexity: O(N) + O(N) ~ O(2N), O(N) for the in-degree array, and O(N) for the queue data structure used in BFS(where N = no.of nodes)."
"Given a graph, find the topological order for the given graph.","Topological sorting/ Topological order : The linear ordering of nodes/vertices such that if there exists an edge between 2 nodes u,v then ‘u’ appears before ‘v’.
There are two approaches for finding the topological order.
Approach 1 : Using BFS
Code in Java : 
import java.util.*;
import java.io.*;
import java.lang.*;

    class Solution
    {
            public boolean isCyclic(int N, ArrayList<ArrayList<Integer>> adj) {
                int topo[] = new int[N];
                int indegree[] = new int[N];
                
                //finding indegree
                for(int i = 0;i<N;i++) {
                    for(Integer it: adj.get(i)) {
                        indegree[it]++;
                    }
                }
                
                
                Queue<Integer> q = new LinkedList<Integer>();
                for(int i = 0;i<N;i++) {
                    //adding nodes to queue with indegree = 0
                    if(indegree[i] == 0) {
                        q.add(i);
                    }
                }
                
                int cnt = 0;
                int ind=0;
                
                while(!q.isEmpty()) {
                    Integer node = q.poll();
                    topo[ind++] = node;
                    cnt++;
                    //getting neighbour nodes of popped node and decreasing  their 
                    indegree by1
                    for(Integer it: adj.get(node)) {
                        indegree[it]--;
                        if(indegree[it] == 0) {
                            q.add(it);
                        }
                    }
                }
                 //printing topological ordering of nodes
                for (int i=0;i< topo.length;i++){
                    System.out.print(topo[i]+"" "");
                }
                if(cnt == N) return false;
                return true;
            }
        }
public class TopoLogicalSortBFS {
        public static void main(String args[]) {

            ArrayList < ArrayList < Integer >> adj = new ArrayList < > ();

            // adding new arraylists to 'adj' to add neighbour nodes
            for (int i = 0; i < 6; i++) {
                adj.add(new ArrayList < > ());
            }


            adj.get(5).add(2);
            adj.get(5).add(0);
            adj.get(4).add(0);
            adj.get(4).add(1);
            adj.get(3).add(1);
            adj.get(2).add(3);


           new Solution().isCyclic(6,adj);

        }
    }
Complexity analysis : 
Time Complexity: O(N+E)

Space complexity: O(N)+O(N)
Approach 2 :  Using DFS 
Code in Java : 
import java.util.*;
class Solution {
    static void findTopoSort(int node, int vis[], ArrayList<ArrayList<Integer>> adj, Stack<Integer> st) {
        vis[node] = 1; 
        for(Integer it: adj.get(node)) {
            if(vis[it] == 0) {
                findTopoSort(it, vis, adj, st); 
            } 
        }
        st.push(node); 
    }
    static int[] topoSort(int N, ArrayList<ArrayList<Integer>> adj) {
        Stack<Integer> st = new Stack<Integer>(); 
        int vis[] = new int[N]; 
        
        for(int i = 0;i<N;i++) {
            if(vis[i] == 0) {
                findTopoSort(i, vis, adj, st);
            }
        }
        
        int topo[] = new int[N];
        int ind = 0; 
        while(!st.isEmpty()) {
            topo[ind++] = st.pop();
        }
        // for(int i = 0;i<N;i++) System.out.println(topo[i] + "" ""); 
        return topo; 
    }
    public static void main(String args[])
    {
        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();
        int n=6;
        for(int i=0;i<n;i++)
        {
            ArrayList<Integer> arr=new ArrayList<>();
            adj.add(arr);
        }
        
        adj.get(5).add(2);
        adj.get(5).add(0);
        adj.get(4).add(0);
        adj.get(4).add(1);
        adj.get(2).add(3);
        adj.get(3).add(1);
        
        int res[] = topoSort(6, adj);
   
        System.out.println(""Toposort of the given graph is:"" );
        for (int i = 0; i < res.length; i++) {
        System.out.print(res[i]+"" "");
  }
    }
}
Complexity analysis : 
Time Complexity: O(N+E) 

N = Number of node , E = Number of Edges

Space Complexity: O(N) + O(N)

Visited Array and Stack data structure. Both will be using O(N).

Auxiliary Space Complexity:  O(N)

Recursion call of DFS"
Check whether the graph is bipartite or not.,"A bipartite graph is a graph which can be coloured using 2 colours such that no adjacent nodes have the same colour. 
Approach : Any linear graph with no cycle is always a bipartite graph. With a cycle, any graph with an even cycle length can also be a bipartite graph. So, any graph with an odd cycle length can never be a bipartite graph.

The intuition is the brute force of filling colours using any traversal technique, just make sure no two adjacent nodes have the same colour. If at any moment of traversal, we find the adjacent nodes to have the same colour, it means that there is an odd cycle, or it cannot be a bipartite graph. 
Code in Java (Using DFS traversal technique) :
import java.util.*;

class Solution
{
    private boolean dfs(int node, int col, int color[], 
    ArrayList<ArrayList<Integer>>adj) {
        
        color[node] = col; 
        
        // traverse adjacent nodes
        for(int it : adj.get(node)) {
            // if uncoloured
            if(color[it] == -1) {
                if(dfs(it, 1 - col, color, adj) == false) return false; 
            }
            // if previously coloured and have the same colour
            else if(color[it] == col) {
                return false; 
            }
        }
        
        return true; 
    }
    public boolean isBipartite(int V, ArrayList<ArrayList<Integer>>adj)
    {
        int color[] = new int[V];
	    for(int i = 0;i<V;i++) color[i] = -1; 
	    
	    // for connected components
	    for(int i = 0;i<V;i++) {
	        if(color[i] == -1) {
	            if(dfs(i, 0, color, adj) == false) return false; 
	        }
	    }
	    return true; 
    }
     public static void main(String[] args)
    {
        // V = 4, E = 4
        ArrayList < ArrayList < Integer >> adj = new ArrayList < > ();
        for (int i = 0; i < 4; i++) {
            adj.add(new ArrayList < > ());
        }
        adj.get(0).add(2);
        adj.get(2).add(0);
        adj.get(0).add(3);
        adj.get(3).add(0);
        adj.get(1).add(3);
        adj.get(3).add(1);
        adj.get(2).add(3);
        adj.get(3).add(2);

        Solution obj = new Solution();
        boolean ans = obj.isBipartite(4, adj);
        if(ans)
            System.out.println(""1"");
        else System.out.println(""0"");
    }

}
Complexity analysis : 
Time Complexity: O(V + 2E), Where V = Vertices, 2E is for total degrees as we traverse all adjacent nodes.

Space Complexity: O(3V) ~ O(V), Space for DFS stack space, colour array and an adjacency list. 
"
Find the number of strongly connected components in the graph.,"A component is called a Strongly Connected Component(SCC) only if for every possible pair of vertices (u, v) inside that component, u is reachable from v and v is reachable from u.
To find the strongly connected components of a given directed graph, we are going to use Kosaraju’s Algorithm.
Algorithm : 
The algorithm steps are as follows:
-Sort all the nodes according to their finishing time:
To sort all the nodes according to their finishing time, we will start DFS from node 0 and while backtracking in the DFS call we will store the nodes in a stack data structure. The nodes in the last SCC will finish first and will be stored in the last of the stack. After the DFS gets completed for all the nodes, the stack will be storing all the nodes in the sorted order of their finishing time.
-Reverse all the edges of the entire graph:
Now, we will create another adjacency list and store the information of the graph in a reversed manner.
-Perform the DFS and count the no. of different DFS calls to get the no. of SCC:
Now, we will start DFS from the node which is on the top of the stack and continue until the stack becomes empty. For each individual DFS call, we will increment the counter variable by 1. We will get the number of SCCs by just counting the number of individual DFS calls as in each individual DFS call, all the nodes of a particular SCC get visited.
-Finally, we will get the number of SCCs in the counter variable. If we want to store the SCCs as well, we need to store the nodes in some array during each individual DFS call in step 3.

Code in Java : 
import java.io.*;
import java.util.*;

//User function Template for Java

class Solution {
    private void dfs(int node, int []vis, ArrayList<ArrayList<Integer>> adj,
                     Stack<Integer> st) {
        vis[node] = 1;
        for (Integer it : adj.get(node)) {
            if (vis[it] == 0) {
                dfs(it, vis, adj, st);
            }
        }
        st.push(node);
    }
    private void dfs3(int node, int[] vis, ArrayList<ArrayList<Integer>> adjT) {
        vis[node] = 1;
        for (Integer it : adjT.get(node)) {
            if (vis[it] == 0) {
                dfs3(it, vis, adjT);
            }
        }
    }
    //Function to find number of strongly connected components in the graph.
    public int kosaraju(int V, ArrayList<ArrayList<Integer>> adj) {
        int[] vis = new int[V];
        Stack<Integer> st = new Stack<Integer>();
        for (int i = 0; i < V; i++) {
            if (vis[i] == 0) {
                dfs(i, vis, adj, st);
            }
        }

        ArrayList<ArrayList<Integer>> adjT = new ArrayList<ArrayList<Integer>>();
        for (int i = 0; i < V; i++) {
            adjT.add(new ArrayList<Integer>());
        }
        for (int i = 0; i < V; i++) {
            vis[i] = 0;
            for (Integer it : adj.get(i)) {
                // i -> it
                // it -> i
                adjT.get(it).add(i);
            }
        }
        int scc = 0;
        while (!st.isEmpty()) {
            int node = st.peek();
            st.pop();
            if (vis[node] == 0) {
                scc++;
                dfs3(node, vis, adjT);
            }
        }
        return scc;
    }
}

class Main {
    public static void main (String[] args) {
        int n = 5;
        int[][] edges = {
            {1, 0}, {0, 2},
            {2, 1}, {0, 3},
            {3, 4}
        };
        ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<Integer>());
        }
        for (int i = 0; i < n; i++) {
            adj.get(edges[i][0]).add(edges[i][1]);
        }
        Solution obj = new Solution();
        int ans = obj.kosaraju(n, adj);
        System.out.println(""The number of strongly connected components is: "" + ans);
    }
}
Complexity analysis : 
Time Complexity: O(V+E) + O(V+E) + O(V+E) ~ O(V+E) , where V = no. of vertices, E = no. of edges. The first step is a simple DFS, so the first term is O(V+E). The second step of reversing the graph and the third step, containing DFS again, will take O(V+E) each.

Space Complexity: O(V)+O(V)+O(V+E), where V = no. of vertices, E = no. of edges. Two O(V) for the visited array and the stack we have used. O(V+E) space for the reversed adjacent list.
"
Print Shortest Path - Dijkstra’s Algorithm,"Approach : 
The intuition behind the above problem is based on Dijkstra's Algorithm with a combination of a little bit of memoization in order to print the shortest possible path and not just calculate the shortest distance between the source and the destination node. In order to print the path we will try to remember the node from which we came while traversing each node by Dijkstra’s Algorithm along with calculating the shortest distance. 

An array called ‘parent’ can be used for this purpose which would store the parent node for each node and will update itself if a shorter path from a node is found at some point in time. This will help us to print the path easily at the end by backtracking through the parent array till we reach the source node.
Code in Java : 
import java.util.*;

class Pair{
    int first;
    int second;
    public Pair(int first,int second){
        this.first = first;
        this.second = second;
    }
}
class Solution {
    public static List<Integer> shortestPath(int n, int m, int edges[][]) {

        // Create an adjacency list of pairs of the form node1 -> {node2, edge weight}
        // where the edge weight is the weight of the edge from node1 to node2.
        ArrayList<ArrayList<Pair>> adj = new ArrayList<>(); 
        for(int i = 0;i<=n;i++) {
            adj.add(new ArrayList<>()); 
        }
        for(int i = 0;i<m;i++) {
            adj.get(edges[i][0]).add(new Pair(edges[i][1], edges[i][2])); 
            adj.get(edges[i][1]).add(new Pair(edges[i][0], edges[i][2])); 
        }
        
        // Create a priority queue for storing the nodes along with distances 
        // in the form of a pair { dist, node }.
        PriorityQueue<Pair> pq = 
        new PriorityQueue<Pair>((x,y) -> x.first - y.first);

        // Create a dist array for storing the updated distances and a parent array
        //for storing the nodes from where the current nodes represented by indices of
        // the parent array came from.
        int[] dist = new int[n+1]; 
        int[] parent =new int[n+1]; 
        for(int i = 1;i<=n;i++) {
            dist[i] = (int)(1e9); 
            parent[i] = i; 
        }
        
        dist[1] = 0; 

        // Push the source node to the queue.
        pq.add(new Pair(0, 1)); 
        while(pq.size() != 0) {

            // Topmost element of the priority queue is with minimum distance value.
            Pair it = pq.peek(); 
            int node = it.second;
            int dis = it.first; 
            pq.remove(); 
            
            // Iterate through the adjacent nodes of the current popped node.
            for(Pair iter : adj.get(node)) {
                int adjNode = iter.first; 
                int edW = iter.second;

                // Check if the previously stored distance value is 
                // greater than the current computed value or not, 
                // if yes then update the distance value.
                if(dis + edW < dist[adjNode]) {
                    dist[adjNode] = dis + edW;
                    pq.add(new Pair(dis + edW, adjNode)); 

                    // Update the parent of the adjNode to the recent 
                    // node where it came from.
                    parent[adjNode] = node; 
                }
            }
        }

        // Store the final path in the ‘path’ array.
        List<Integer> path = new ArrayList<>();  

        // If distance to a node could not be found, return an array containing -1.
        if(dist[n] == 1e9) {
            path.add(-1); 
            return path; 
        }
        
        int node = n;
        // o(N)
        while(parent[node] != node) {
            path.add(node); 
            node = parent[node]; 
        }
        path.add(1); 

        // Since the path stored is in a reverse order, we reverse the array
        // to get the final answer and then return the array.
        Collections.reverse(path); 
        return path;
    }
}

class driver {

    public static void main(String[] args) {
        int V = 5, E = 6;

        int[][] edges = {{1,2,2},{2,5,5},{2,3,4},{1,4,1},{4,3,3},{3,5,1}};

        Solution obj = new Solution();
        List < Integer > path = obj.shortestPath(V, E, edges);
        for (int i = 0; i < path.size(); i++) {
            System.out.print(path.get(i) + "" "");
        }
        System.out.println();
    }
}
Time Complexity: O( E log(V) ) { for Dijkstra’s Algorithm } + O(V) { for backtracking in order to find the parent for each node } Where E = Number of edges and V = Number of Nodes.

Space Complexity: O( |E| + |V| ) { for priority queue and dist array } + O( |V| ) { for storing the final path } Where E = Number of edges and V = Number of Nodes."
Bellman Ford Algorithm - Find the shortest distance of all the vertices from the source vertex S.,"The bellman-Ford algorithm helps to find the shortest distance from the source node to all other nodes. 
In this algorithm, the edges can be given in any order. The intuition is to relax all the edges for N-1( N = no. of nodes) times sequentially. After N-1 iterations, we should have minimized the distance to every node.
Code in Java : 
import java.util.*;

/*
*   edges: vector of vectors which represents the graph
*   S: source vertex to start traversing graph with
*   V: number of vertices
*/
class Solution {
    static int[] bellman_ford(int V,
                              ArrayList<ArrayList<Integer>> edges, int S) {
        int[] dist = new int[V];
        for (int i = 0; i < V; i++) dist[i] = (int)(1e8);
        dist[S] = 0;
        // V x E
        for (int i = 0; i < V - 1; i++) {
            for (ArrayList<Integer> it : edges) {
                int u = it.get(0);
                int v = it.get(1);
                int wt = it.get(2);
                if (dist[u] != 1e8 && dist[u] + wt < dist[v]) {
                    dist[v] = dist[u] + wt;
                }
            }
        }
        // Nth relaxation to check negative cycle
        for (ArrayList<Integer> it : edges) {
            int u = it.get(0);
            int v = it.get(1);
            int wt = it.get(2);
            if (dist[u] != 1e8 && dist[u] + wt < dist[v]) {
                int temp[] = new int[1];
                temp[0] = -1;
                return temp;
            }
        }
        return dist;
    }
}

public class tUf {
    public static void main(String[] args) {
        int V = 6;
        int S = 0;
        ArrayList<ArrayList<Integer>> edges = new ArrayList<>() {
            {
                add(new ArrayList<Integer>(Arrays.asList(3, 2, 6)));
                add(new ArrayList<Integer>(Arrays.asList(5, 3, 1)));
                add(new ArrayList<Integer>(Arrays.asList(0, 1, 5)));
                add(new ArrayList<Integer>(Arrays.asList(1, 5, -3)));
                add(new ArrayList<Integer>(Arrays.asList(1, 2, -2)));
                add(new ArrayList<Integer>(Arrays.asList(3, 4, -2)));
                add(new ArrayList<Integer>(Arrays.asList(2, 4, 3)));
            }
        };



        int[] dist = Solution.bellman_ford(V, edges, S);
        for (int i = 0; i < V; i++) {
            System.out.print(dist[i] + "" "");
        }
        System.out.println("""");
    }
}
Complexity analysis : 
Time Complexity: O(V*E), where V = no. of vertices and E = no. of Edges.

Space Complexity: O(V) for the distance array which stores the minimized distances."
Floyd Warshall Algorithm -  find the shortest distances between every pair of vertices in a given edge-weighted directed graph.,"Basically, the Floyd Warshall algorithm is a multi-source shortest path algorithm and it helps to detect negative cycles as well. The shortest path between node u and v necessarily means the path(from u to v) for which the sum of the edge weights is minimum.

In Floyd Warshall's algorithm, we need to check every possible path going via each possible node. And after checking every possible path, we will figure out the shortest path(a kind of brute force approach to find the shortest path). The intuition is to check all possible paths between every possible pair of nodes and to choose the shortest one. Checking all possible paths means going via each and every possible node.   
Code in Java : 
import java.util.*;

class Solution {
    public void shortest_distance(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == -1) {
                    matrix[i][j] = (int)(1e9);
                }
                if (i == j) matrix[i][j] = 0;
            }
        }

        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    matrix[i][j] = Math.min(matrix[i][j],
                                            matrix[i][k] + matrix[k][j]);
                }
            }
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == (int)(1e9)) {
                    matrix[i][j] = -1;
                }
            }
        }
    }
}

public class driver{
    public static void main(String[] args) {
        int V = 4;
        int[][] matrix = new int[V][V];

        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                matrix[i][j] = -1;
            }
        }

        matrix[0][1] = 2;
        matrix[1][0] = 1;
        matrix[1][2] = 3;
        matrix[3][0] = 3;
        matrix[3][1] = 5;
        matrix[3][2] = 4;

        Solution obj = new Solution();
        obj.shortest_distance(matrix);

        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                System.out.print(matrix[i][j] + "" "");
            }
            System.out.println("""");
        }
    }
} 
Complexity analysis : 
Time Complexity: O(V3), as we have three nested loops each running for V times, where V = no. of vertices.

Space Complexity: O(V2), where V = no. of vertices. This space complexity is due to storing the adjacency matrix of the given graph."
Program / Code for Prim's Algorithm - Minimum Spanning Tree,"The intuition of Prim's algorithm is the greedy technique used for every node. If we carefully observe, for every node, we are greedily selecting its unvisited adjacent node with the minimum edge weight(as the priority queue here is a min-heap and the topmost element is the node with the minimum edge weight). Doing so for every node, we can get the sum of all the edge weights of the minimum spanning tree and the spanning tree itself(if we wish to) as well.
In order to implement Prim’s algorithm, we will be requiring an array(visited array) and a priority queue that will essentially represent a min-heap. We need another array(MST) as well if we wish to store the edge information of the minimum spanning tree.
Code in Java : 
import java.util.*;


class Pair {
    int node;
    int distance;
    public Pair(int distance, int node) {
        this.node = node;
        this.distance = distance;
    }
}
class Solution {
    //Function to find sum of weights of edges of the Minimum Spanning Tree.
    static int spanningTree(int V,
                            ArrayList<ArrayList<ArrayList<Integer>>> adj) {
        PriorityQueue<Pair> pq =
            new PriorityQueue<Pair>((x, y) -> x.distance - y.distance);

        int[] vis = new int[V];
        // {wt, node}
        pq.add(new Pair(0, 0));
        int sum = 0;
        while (pq.size() > 0) {
            int wt = pq.peek().distance;
            int node = pq.peek().node;
            pq.remove();

            if (vis[node] == 1) continue;
            // add it to the mst
            vis[node] = 1;
            sum += wt;

            for (int i = 0; i < adj.get(node).size(); i++) {
                int edW = adj.get(node).get(i).get(1);
                int adjNode = adj.get(node).get(i).get(0);
                if (vis[adjNode] == 0) {
                    pq.add(new Pair(edW, adjNode));
                }
            }
        }
        return sum;
    }
}

public class driver{
    public static void main(String[] args) {
        int V = 5;
        ArrayList<ArrayList<ArrayList<Integer>>> adj = new ArrayList<ArrayList<ArrayList<Integer>>>();
        int[][] edges =  {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};

        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<ArrayList<Integer>>());
        }

        for (int i = 0; i < 6; i++) {
            int u = edges[i][0];
            int v = edges[i][1];
            int w = edges[i][2];

            ArrayList<Integer> tmp1 = new ArrayList<Integer>();
            ArrayList<Integer> tmp2 = new ArrayList<Integer>();
            tmp1.add(v);
            tmp1.add(w);

            tmp2.add(u);
            tmp2.add(w);

            adj.get(u).add(tmp1);
            adj.get(v).add(tmp2);
        }

        Solution obj = new Solution();
        int sum = obj.spanningTree(V, adj);
        System.out.println(""The sum of all the edge weights: "" + sum);
    }
}
Complexity analysis : 
Time Complexity: O(E*logE) + O(E*logE)~ O(E*logE), where E = no. of given edges.
The maximum size of the priority queue can be E so after at most E iterations the priority queue will be empty and the loop will end. Inside the loop, there is a pop operation that will take logE time. This will result in the first O(E*logE) time complexity. Now, inside that loop, for every node, we need to traverse all its adjacent nodes where the number of nodes can be at most E. If we find any node unvisited, we will perform a push operation and for that, we need a logE time complexity. So this will result in the second O(E*logE). 

Space Complexity: O(E) + O(V), where E = no. of edges and V = no. of vertices. O(E) occurs due to the size of the priority queue and O(V) due to the visited array. If we wish to get the mst, we need an extra O(V-1) space to store the edges of the most."
Program / Code for Kruskal's Algorithm - Minimum Spanning Tree,"We will be implementing Kruskal’s algorithm using the Disjoint Set data structure.
Code in Java : 
import java.io.*;
import java.util.*;

class DisjointSet {
    List<Integer> rank = new ArrayList<>();
    List<Integer> parent = new ArrayList<>();
    List<Integer> size = new ArrayList<>();
    public DisjointSet(int n) {
        for (int i = 0; i <= n; i++) {
            rank.add(0);
            parent.add(i);
            size.add(1);
        }
    }

    public int findUPar(int node) {
        if (node == parent.get(node)) {
            return node;
        }
        int ulp = findUPar(parent.get(node));
        parent.set(node, ulp);
        return parent.get(node);
    }

    public void unionByRank(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (rank.get(ulp_u) < rank.get(ulp_v)) {
            parent.set(ulp_u, ulp_v);
        } else if (rank.get(ulp_v) < rank.get(ulp_u)) {
            parent.set(ulp_v, ulp_u);
        } else {
            parent.set(ulp_v, ulp_u);
            int rankU = rank.get(ulp_u);
            rank.set(ulp_u, rankU + 1);
        }
    }

    public void unionBySize(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (size.get(ulp_u) < size.get(ulp_v)) {
            parent.set(ulp_u, ulp_v);
            size.set(ulp_v, size.get(ulp_v) + size.get(ulp_u));
        } else {
            parent.set(ulp_v, ulp_u);
            size.set(ulp_u, size.get(ulp_u) + size.get(ulp_v));
        }
    }
}
class Edge implements Comparable<Edge> {
    int src, dest, weight;
    Edge(int _src, int _dest, int _wt) {
        this.src = _src; this.dest = _dest; this.weight = _wt;
    }
    // Comparator function used for
    // sorting edgesbased on their weight
    public int compareTo(Edge compareEdge) {
        return this.weight - compareEdge.weight;
    }
};
class Solution {
    //Function to find sum of weights of edges of the Minimum Spanning Tree.
    static int spanningTree(int V,
                            ArrayList<ArrayList<ArrayList<Integer>>> adj) {
        List<Edge> edges = new ArrayList<Edge>();
        // O(N + E)
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < adj.get(i).size(); j++) {
                int adjNode = adj.get(i).get(j).get(0);
                int wt = adj.get(i).get(j).get(1);
                int node = i;
                Edge temp = new Edge(i, adjNode, wt);
                edges.add(temp);
            }
        }
        DisjointSet ds = new DisjointSet(V);
        // M log M
        Collections.sort(edges);
        int mstWt = 0;
        // M x 4 x alpha x 2
        for (int i = 0; i < edges.size(); i++) {
            int wt = edges.get(i).weight;
            int u = edges.get(i).src;
            int v = edges.get(i).dest;

            if (ds.findUPar(u) != ds.findUPar(v)) {
                mstWt += wt;
                ds.unionBySize(u, v);
            }
        }

        return mstWt;
    }
}

class Main {
    public static void main (String[] args) {
        int V = 5;
        ArrayList<ArrayList<ArrayList<Integer>>> adj = new ArrayList<ArrayList<ArrayList<Integer>>>();
        int[][] edges =  {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};

        for (int i = 0; i < V; i++) {
            adj.add(new ArrayList<ArrayList<Integer>>());
        }

        for (int i = 0; i < 6; i++) {
            int u = edges[i][0];
            int v = edges[i][1];
            int w = edges[i][2];

            ArrayList<Integer> tmp1 = new ArrayList<Integer>();
            ArrayList<Integer> tmp2 = new ArrayList<Integer>();
            tmp1.add(v);
            tmp1.add(w);

            tmp2.add(u);
            tmp2.add(w);

            adj.get(u).add(tmp1);
            adj.get(v).add(tmp2);
        }

        Solution obj = new Solution();
        int mstWt = obj.spanningTree(V, adj);
        System.out.println(""The sum of all the edge weights: "" + mstWt);

    }
}
Complexity analysis : 
Time Complexity: O(N+E) + O(E logE) + O(E*4α*2)   where N = no. of nodes and E = no. of edges. O(N+E) for extracting edge information from the adjacency list. O(E logE) for sorting the array consists of the edge tuples. Finally, we are using the disjoint set operations inside a loop. The loop will continue to E times. Inside that loop, there are two disjoint set operations like findUPar() and UnionBySize() each taking 4 and so it will result in 4*2. That is why the last term O(E*4*2) is added.

Space Complexity: O(N) + O(N) + O(E) where E = no. of edges and N = no. of nodes. O(E) space is taken by the array that we are using to store the edge information. And in the disjoint set data structure, we are using two N-sized arrays i.e. a parent and a size array (as we are using unionBySize() function otherwise, a rank array of the same size if unionByRank() is used) which result in the first two terms O(N)."
What is Disjoint set datastructure ? ,"The disjoint Set data structure is generally used for dynamic graphs.  A dynamic graph generally refers to a graph that keeps on changing its configuration
Let’s consider the edge information for a given graph as: {{1,2}, {2,3}, {4,5}, {6,7}, {5,6}, {3,7}}. Now if we start adding the edges one by one, in each step the structure of the graph will change. So, after each step, if we perform the same operation on the graph while updating the edges, the result might be different. In this case, the graph will be considered a dynamic graph.

A Disjoint Set (also known as Union-Find or Merge-Find) is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. Disjoint Set is mainly used for operations like finding whether two elements are in the same subset, merging two subsets, and finding the representative (or leader) element of a subset.

The main operations in a Disjoint Set are:

MakeSet(x): Creates a new set whose only member (and representative) is x.
Find(x): Returns the representative of the set that x belongs to. It's used to determine the subset to which a particular element belongs.
Union(x, y): Merges the two sets that contain x and y, respectively, into a single set.
Basic implementation of disjoint set in Java : 
class DisjointSet {
    int[] parent;
    int[] rank;

    public DisjointSet(int n) {
        parent = new int[n];
        rank = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i; // Initially, each element is the representative of its own set
            rank[i] = 0; // Initial rank of each set is 0
        }
    }

    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // Path compression
        }
        return parent[x];
    }

    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX != rootY) {
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        DisjointSet ds = new DisjointSet(5);

        ds.union(0, 2);
        ds.union(4, 2);
        ds.union(3, 1);

        // Check if elements 1 and 4 are in the same set
        if (ds.find(1) == ds.find(4)) {
            System.out.println(""1 and 4 are in the same set"");
        } else {
            System.out.println(""1 and 4 are in different sets"");
        }
    }
}
"
Program / Code to Implement Trie,"Trie is a data structure that is like a tree data structure in its organisation. It consists of nodes that store letters or alphabets of words, which can be added, retrieved, and deleted from it in a very efficient way.

In other words, Trie is an information retrieval data structure, which can beat naive data structures like Hashmap, Tree, etc in the time complexity of its operations.

Code in Java : 
                            
public class Trie {

    // Node structure for Trie
    static class Node {
        // Array to store links to child nodes,
        // each index represents a letter
        Node[] links = new Node[26];
        // Flag indicating if the node
        // marks the end of a word
        boolean flag = false;

        // Check if the node contains
        // a specific key (letter)
        boolean containsKey(char ch) {
            return links[ch - 'a'] != null;
        }

        // Insert a new node with a specific
        // key (letter) into the Trie
        void put(char ch, Node node) {
            links[ch - 'a'] = node;
        }

        // Get the node with a specific
        // key (letter) from the Trie
        Node get(char ch) {
            return links[ch - 'a'];
        }

        // Set the current node
        // as the end of a word
        void setEnd() {
            flag = true;
        }

        // Check if the current node
        // marks the end of a word
        boolean isEnd() {
            return flag;
        }
    }

    // Trie class
    private Node root;

    // Constructor to initialize the
    // Trie with an empty root node
    public Trie() {
        root = new Node();
    }

    // Inserts a word into the Trie
    // Time Complexity O(len), where len
    // is the length of the word
    public void insert(String word) {
        Node node = root;
        for (int i = 0; i < word.length(); i++) {
            if (!node.containsKey(word.charAt(i))) {
                // Create a new node for
                // the letter if not present
                node.put(word.charAt(i), new Node());
            }
            // Move to the next node
            node = node.get(word.charAt(i));
        }
        // Mark the end of the word
        node.setEnd();
    }

    // Returns if the word
    // is in the trie
    public boolean search(String word) {
        Node node = root;
        for (int i = 0; i < word.length(); i++) {
            if (!node.containsKey(word.charAt(i))) {
                // If a letter is not found,
                // the word is not in the Trie
                return false;
            }
            // Move to the next node
            node = node.get(word.charAt(i));
        }
        // Check if the last node
        // marks the end of a word
        return node.isEnd();
    }

    // Returns if there is any word in the
    // trie that starts with the given prefix
    public boolean startsWith(String prefix) {
        Node node = root;
        for (int i = 0; i < prefix.length(); i++) {
            if (!node.containsKey(prefix.charAt(i))) {
                // If a letter is not found, there is
                // no word with the given prefix
                return false;
            }
            // Move to the next node
            node = node.get(prefix.charAt(i));
        }
        // The prefix is found in the Trie
        return true;
    }

    public static void main(String[] args) {
        Trie trie = new Trie();
        System.out.println(""Inserting words: Striver, Striving, String, Strike"");
        trie.insert(""striver"");
        trie.insert(""striving"");
        trie.insert(""string"");
        trie.insert(""strike"");

        System.out.println(""Search if Strawberry exists in trie: "" +
                (trie.search(""strawberry"") ? ""True"" : ""False""));

        System.out.println(""Search if Strike exists in trie: "" +
                (trie.search(""strike"") ? ""True"" : ""False""));

        System.out.println(""If words in Trie start with Stri: "" +
                (trie.startsWith(""stri"") ? ""True"" : ""False""));
    }
}
 Complexity Analysis
Time Complexity:

Insertion: O(N) where N is the length of the word being inserted. This is because we have to iterate over each letter of the word to find its corresponding node or create a node accordingly.
Search: O(N) where N is the length of the word being searched for. This is because in Trie search we traverse over each letter for the word from the root, checking if the current node contains a node at the index of the next letter. This process repeats until we reach the end of the word or encounter a node without the next letter.
Prefix Search: O(N) where N is the length of the prefix being searched for. Similar to searching for words, in prefix search we also iterate over each letter of the word to find its corresponding node.
Space Complexity: O(N) where N is the total number of characters across all unique words inserted into the Trie. For each character in a word, a new node may need to be created leading to space proportional to the number of characters.                     
                        "
Number of Distinct Substrings in a String Using Trie,"Code in Java : 
                                
import java.util.HashMap;

// Node structure representing
// each node in the trie
class Node {
    Node[] links;  
    // Array of pointers to child nodes,
    // each corresponding to a letter
    // of the alphabet
    boolean flag;  
    // Flag indicating if the current
    // node represents the end of a substring

    // Method to check if a specific character key
    // exists in the children of the current node
    public boolean containsKey(char ch) {  
        // Check if the current node has a child node
        // corresponding to character 'ch'
        return links[ch - 'a'] != null;
    }

    // Method to get the child node corresponding
    // to a specific character key
    public Node get(char ch) {  
        // Get the child node
        // corresponding to character 'ch'
        return links[ch - 'a'];
    }

    // Method to insert a new child
    // node with a specific character key
    public void put(char ch, Node node) {  
        // Insert a new child
        // node for character 'ch'
        links[ch - 'a'] = node;
    }

    // Method to mark the current
    // node as the end of a substring
    public void setEnd() {  
        // Mark the current node
        // as the end of a substring
        flag = true;
    }

    // Method to check if the current
    // node marks the end of a substring
    public boolean isEnd() {  
        // Check if the current node
        // marks the end of a substring
        return flag;
    }
}

// Function to count the number of
// distinct substrings in the given string
public class Main {  
    // Function to count the number of
    // distinct substrings in the given string
    public static int countDistinctSubstrings(String s) {  
        // Function to count distinct
        // substrings in the input string 's'
        Node root = new Node();  
        // Creating the root
        // node of the trie
        int cnt = 0;  
        // Counter to keep track
        // of distinct substrings
        int n = s.length();  
        // Length of the input string

        // Nested loops to iterate through all
        // possible substrings of the input string
        for (int i = 0; i < n; i++) {  
            // Iterate through each
            // starting position of the substring
            Node node = root;  
            // Start from the root for each substring
            for (int j = i; j < n; j++) {  
                // Iterate through each character of the substring
                // If the current character is not a child
                // of the current node, insert it as a new child node
                if (!node.containsKey(s.charAt(j))) {
                    node.put(s.charAt(j), new Node());  
                    // Insert a new child
                    // node for character s.charAt(j)
                    cnt++;  
                    // Increment the counter
                    // since a new substring is found
                }
                node = node.get(s.charAt(j));  
                // Move to the child node
                // corresponding to character s.charAt(j)
            }
        }
        return cnt + 1;  
        // Return the total count of distinct substrings
        // (+1 to account for the input string itself)
    }

    // Main function to test the
    // countDistinctSubstrings function
    public static void main(String[] args) {  
        String s = ""striver"";  
        // Input string
        System.out.println(""Current String: "" + s);
        System.out.println(""Number of distinct substrings: "" + countDistinctSubstrings(s));  
        // Output the result
    }
}
                                
Complexity Analysis
Time Complexity: O(N*N)where N is the length of the input string. This is because for each starting position of the substring, we traverse the entire substring once. However, due to the Trie structure, the actual number of comparisons is reduced as we progress.

Space Complexity : O(N*N) where N is the length of the input string. In the worst-case scenario, where there are no common prefixes among substrings the number of nodes could be as high as the total number of substrings which is bounded by O(N*N).
                        "
" Given a string, find all the possible subsequences of the string - Power Set.","Approach :  Using recursion(Backtacking) 
Code in Java : 
import java.util.*;
class solution{
static void solve(int i, String s, String f) {
	if (i == s.length()) {
		System.out.print(f+"" "");
		return;
	}
	//picking 
	//f = f + s.charAt(i);
	solve(i + 1, s,  f+s.charAt(i));
	//poping out while backtracking
	//f.pop_back();
	solve(i + 1, s,  f);
}
public static void main(String args[]) {
	String s = ""abc"";
	String f = """";
	System.out.println(""All possible subsequences are: "");
	solve(0, s, f);
}
}
Complexity analysis : 
Time Complexity: O(2^n)

Space Complexity: O(n), recursion stack."
Can Binary Search be applied to an unsorted array?,"No, Binary Search requires a sorted array to work correctly. If the array is unsorted, Binary Search will not provide correct results."
How do you handle duplicates in Binary Search?,"Binary Search can handle duplicates, but it might not return the first or last occurrence of the element. To handle duplicates, you can modify the search process to stop when you find an occurrence of the element and then check adjacent elements for duplicates."
Can Binary Search be used on a linked list?,"Yes, Binary Search can be used on a linked list, but it will be less efficient compared to using it on an array because it does not have direct access to elements by index, requiring traversal to the middle element which takes O(n/2) time for each step."
Explain the adjacency matrix representation of a graph.,"An adjacency matrix is a 2D array where the rows and columns represent vertices, and the presence of an edge between two vertices is indicated by a non-zero value in the corresponding cell. For an unweighted graph, the cell can contain 1 if there's an edge or 0 if there's no edge. For weighted graphs, the cell can contain the weight of the edge."
Explain the adjacency list representation of a graph.,An adjacency list is a collection of lists or arrays where each list/array represents a vertex and contains the vertices adjacent to it. This representation is more memory-efficient for sparse graphs and supports faster iteration over neighbors of a vertex.
What is the difference between a mutable and immutable string?,"A mutable string can be modified after it is created, while an immutable string cannot be modified. In many programming languages like Python, strings are immutable, meaning once they are created, their contents cannot be changed."
"Explain the difference between substring, subsequence, and suffix.","A substring is a contiguous sequence of characters within a string. A subsequence is a sequence of characters that appears in the same order as in the original string, but not necessarily contiguous. A suffix is a substring that occurs at the end of the string."
"What is the time complexity of basic string operations like accessing a character, concatenating two strings, and finding the length of a string?","Accessing a character in a string (assuming a constant index) is O(1). Concatenating two strings is typically O(n), where n is the length of the concatenated string. Finding the length of a string is usually O(1) in languages where strings store their length explicitly."
Explain the concept of string matching algorithms.,"String matching algorithms are techniques used to find occurrences of a substring within a larger string. This includes simple algorithms like brute-force search, and more advanced ones like Knuth-Morris-Pratt (KMP) algorithm, Boyer-Moore algorithm, and Rabin-Karp algorithm."
What is a palindrome?,"A palindrome is a string that reads the same forwards and backwards, ignoring spaces, punctuation, and capitalization."
What is string hashing?,String hashing is the process of mapping strings to numerical values (hash codes) using hash functions. These hash codes are used in various algorithms and data structures like hash tables for efficient storage and retrieval.
What is the difference between a greedy algorithm and a dynamic programming algorithm?,"Greedy algorithms make a series of locally optimal choices with the hope that this will lead to a globally optimal solution, while dynamic programming breaks down a problem into smaller subproblems and solves each subproblem just once, saving the solutions for future use."
What is the difference between a recursive and an iterative algorithm?," A recursive algorithm is one that calls itself to solve smaller instances of the same problem, while an iterative algorithm uses loops to repeatedly execute a set of instructions until the desired result is achieved."
What is the purpose of sorting algorithms?,What is the purpose of sorting algorithms?
Give examples of divide and conquer algorithms.,"Examples of divide and conquer algorithms include Merge Sort, Quick Sort, Binary Search, and Strassen's Matrix Multiplication."
What is a backtracking algorithm?,"Backtracking is a technique for solving problems by incrementally building a solution, one piece at a time, and backtracking when the algorithm reaches a dead end. Examples include the N-Queens problem and Sudoku solving."
Explain the difference between a deterministic and a probabilistic algorithm.,"A deterministic algorithm always produces the same output for a given input, while a probabilistic algorithm may produce different outputs for the same input, depending on randomness or probability distributions involved in the algorithm's execution. Examples of probabilistic algorithms include Monte Carlo algorithms.

"
What is a Data Structure?,"The Data Structure is the way data is organized (stored) and manipulated for retrieval and access. It also defines the way different sets of data relate to one another, establishing relationships and forming algorithms."
Describe the types of Data Structures?,"The following are the types of data structures:

Lists: A collection of related things linked to the previous or/and following data items.
Arrays: A collection of values that are all the same.
Records: A collection of fields, each of which contains data from a single data type.
Trees: A data structure that organizes data in a hierarchical framework. This form of data structure follows the ordered order of data item insertion, deletion, and modification.
Tables: The data is saved in the form of rows and columns. These are comparable to records in that the outcome or alteration of data is mirrored across the whole table."
What is a Linear Data Structure? Name a few examples.,"A data structure is linear if all its elements or data items are arranged in a sequence or a linear order. The elements are stored in a non-hierarchical way so that each item has successors and predecessors except the first and last element in the list.

Examples of linear data structures are Arrays, Stack, Strings, Queue, and Linked List."
What are some applications of Data Structures? ,"Numerical analysis, operating system, AI, compiler design, database management, graphics, statistical analysis, and simulation."
What is the difference between file structure and storage structure?,"The difference lies in the memory area accessed. Storage structure refers to the data structure in the memory of the computer system, whereas file structure represents the storage structure in the auxiliary memory."
What is a multidimensional array?,"A multidimensional array is a multidimensional array with more than one dimension. It is an array of arrays or an array with numerous layers. The 2D array, or two-dimensional array, is the most basic multidimensional array. As you'll see in the code, it's technically an array of arrays. A 2D array is also referred to as a matrix or a table with rows and columns. Declaring a multidimensional array is the same as saying a one-dimensional array. We need to notify C that we have two dimensions for a two-dimensional array."
How are the elements of a 2D array stored in the memory?,"Row-Major Order: -In row-major ordering, all of the rows of a 2D array are stored in memory in a contiguous manner.
First, the first row of the array is entirely stored in memory, followed by the second row of the array, and so on until the final row.

Column-Major Order: In column-major ordering, all of the columns of a 2D array are stored in memory in the same order. The first column of the array is entirely saved in memory, followed by the second row of the array, and so on until the last column of the array is wholly recorded in memory."
What is a doubly-linked list? Give some examples.,"It is a complex type (double-ended LL) of a linked list in which a node has two links, one that connects to the next node in the sequence and another that connects to the previous node. This allows traversal across the data elements in both directions. 

Examples include: 

A music playlist with next and previous navigation buttons
The browser cache with BACK-FORWARD visited pages
The undo and redo functionality on a browser, where you can reverse the node to get to the previous page"
How do you reference all of the elements in a one-dimension array?,"Using an indexed loop, we may access all of the elements in a one-dimensional array. The counter counts down from 0 to the maximum array size, n, minus one. The loop counter is used as the array subscript to refer to all items of the one-dimensional array in succession."
What are dynamic Data Structures? Name a few.,"They are collections of data in memory that expand and contract to grow or shrink in size as a program runs. This enables the programmer to control exactly how much memory is to be utilized.

Examples are the dynamic array, linked list, stack, queue, and heap."
 What is an algorithm? ,An algorithm is a step by step method of solving a problem or manipulating data. It defines a set of instructions to be executed in a certain order to get the desired output. 
Why do we need to do an algorithm analysis?,"A problem can be solved in more than one way using several solution algorithms. Algorithm analysis provides an estimation of the required resources of an algorithm to solve a specific computational problem. The amount of time and space resources required to execute is also determined.

The time complexity of an algorithm quantifies the amount of time taken for an algorithm to run as a function of the length of the input. The space complexity quantifies the amount of space or memory taken by an algorithm, to run as a function of the length of the input."
What is a postfix expression?,"A postfix expression is made up of operators and operands, with the operator coming after the operands. That is, in a postfix expression, the operator comes after the operands. Likewise, what is the proper postfix form? The correct postfix phrase is A B + C *."
What is a Dequeue?,"It is a double-ended queue, or a data structure, where the elements can be inserted or deleted at both ends (FRONT and REAR)."
What are the advantages of the heap over a stack?,"In this data structure interview questions, try giving various advantages, along with examples, if possible. It will show the interviewer your domain expertise. Generally, both heap and stack are part of memory and used in Java for different needs: 

Heap is more flexible than the stack because memory space can be dynamically allocated and de-allocated as needed 
Heap memory is used to store objects in Java, whereas stack memory is used to store local variables and function call 
Objects created in the heap are visible to all threads, whereas variables stored in stacks are only visible to the owner as private memory
When using recursion, the size of heap memory is more whereas it quickly fill-ups stack memory "
What is the difference between a PUSH and a POP?,"In terms of data structure interview questions, this is one of the most frequently asked question.

The acronyms stand for Pushing and Popping operations performed on a stack. These are ways data is stored and retrieved. 

PUSH is used to add an item to a stack, while POP is used to remove an item.
PUSH takes two arguments, the name of the stack to add the data to and the value of the entry to be added. POP only needs the name of the stack. 
When the stack is filled and another PUSH command is issued, you get a stack overflow error, which means that the stack can no longer accommodate the last PUSH. In POP, a stack underflow error occurs when you’re trying to POP an already empty stack. "
Which sorting algorithm is considered the fastest? Why?,"A single sorting algorithm can’t be considered best, as each algorithm is designed for a particular data structure and data set. However, the QuickSort algorithm is generally considered the fastest because it has the best performance for most inputs.

Its advantages over other sorting algorithms include the following:

Cache-efficient: It linearly scans and linearly partitions the input. This means we can make the most of every cache load. 
Can skip some swaps: As QuickSort is slightly sensitive to input that is in the right order, it can skip some swaps.
Efficient even in worst-case input sets, as the order is generally random.
Easy adaption to already- or mostly-sorted inputs.
When speed takes priority over stability."
What is an asymptotic analysis of an algorithm?,"Asymptotic analysis is the technique of determining an algorithm's running time in mathematical units to determine the program's limits, also known as ""run-time performance."" The purpose is to identify the best case, worst case, and average-case times for completing a particular activity. While not a deep learning training technique, Asymptotic analysis is an essential diagnostic tool for programmers to analyze an algorithm's efficiency rather than its correctness.
"
What are some examples of divide and conquer algorithms?,"Quicksort is the name of a sorting algorithm. The method selects a pivot element and rearranges the array elements so that all items less than the pivot chosen element go to the left side of the pivot and all elements more significant than the pivot element move to the right side.

Merge Sort is a sorting algorithm as well. The algorithm divides the array into two halves, sorts them recursively, and then combines the two sorted halves. The goal of points that are closest together is to identify the nearest pair of points in an x-y plane collection of points. The issue may be solved in O(n2) time by computing the distances between each pair of locations and comparing them to determine the shortest distance."
What are the differences between the B tree and the B+ tree?,"The B tree is a self-balancing m-way tree, with m defining the tree's order. Depending on the number of m, Btree is an extension of the Binary Search tree in which a node can have more than one key and more than two children. The data is provided in the B tree in a sorted manner, with lower values on the left subtree and higher values on the right subtree.

The B+ tree is an advanced self-balanced tree since every path from the tree's root to its leaf is the same length. The fact that all leaf nodes are the same length indicates that they all occur at the same level. Specific leaf nodes can’t appear at the third level, while others appear at the second level."
What is an AVL tree?,"An AVL (Adelson, Velskii, and Landi) tree is a height balancing binary search tree in which the difference of heights of the left and right subtrees of any node is less than or equal to one. This controls the height of the binary search tree by not letting it get skewed. This is used when working with a large data set, with continual pruning through insertion and deletion of data."
What are the advantages of binary search over a linear search?,"In a sorted list:

A binary search is more efficient than a linear search because we perform fewer comparisons. With linear search, we can only eliminate one element per comparison each time we fail to find the value we are looking for, but with the binary search, we eliminate half the set with each comparison.
Binary search runs in O(log n) time compared to linear search’s O(n) time. This means that the more of the elements present in the search array, the faster is binary search compared to a linear search. "
Do dynamic memory allocations help in managing data? How?,"Dynamic memory allocation stores simple structured data types at runtime. It has the ability to combine separately allocated structured blocks to form composite structures that expand and contract as needed, thus helping manage data of data blocks of arbitrary size, in arbitrary order."
What is a Matrix Data Structure?,"Matrix Data Structure is a two-dimensional array that consists of rows and columns. It is an arrangement of elements in horizontal or vertical lines of entries. It is also considered as an array of arrays, where array at each index has the same size."
Declaration of Matrix Data Structure :,"import java.io.*;

class Main {
    public static void main(String[] args)
    {
        // Defining number of rows and columns in matrix
        int number_of_rows = 3, number_of_columns = 3;
        // Array Declaration
        int[][] arr
            = new int[number_of_rows][number_of_columns];
    }
}"
Initializing Matrix Data Structure:,"In initialization, we assign some initial value to all the cells of the matrix. Below is the implementation to initialize a matrix in different languages:


import java.io.*;

class Main{
    public static void main(String[] args)
    {
        // Initializing a 2-D array with values
        int arr[][]
            = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
    }
}"
Access elements of Matrix Data Structure:,"Like one-dimensional arrays, matrices can be accessed randomly by using their indices to access the individual elements. A cell has two indices, one for its row number, and the other for its column number. We can use arr[i][j] to access the element which is at the ith row and jth column of the matrix.

import java.io.*;

class GFG {
    public static void main(String[] args)
    {

        // Initializing a 2-D array with values
        int[][] arr
            = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };

        // Accessing elements of 2-D array
        System.out.println(""First element of first row: ""
                           + arr[0][0]);
        System.out.println(""Third element of second row: ""
                           + arr[1][2]);
        System.out.println(""Second element of third row: ""
                           + arr[2][1]);
    }
}"
Traversal of a Matrix Data Structure:,"We can traverse all the elements of a matrix or two-dimensional array by using two for-loops.



/*package whatever //do not write package name here */
import java.io.*;

class GFG {
    public static void main(String[] args)
    {
        int[][] arr = { { 1, 2, 3, 4 },
                        { 5, 6, 7, 8 },
                        { 9, 10, 11, 12 } };
        // Traversing over all the rows
        for (int i = 0; i < 3; i++) {
            // Traversing over all the columns of each row
            for (int j = 0; j < 4; j++) {
                System.out.print(arr[i][j] + "" "");
            }
            System.out.println();
        }
    }
}"
Searching in a Matrix Data Structure:,"We can search an element in a matrix by traversing all the elements of the matrix.

Below is the implementation to search an element in a matrix:


// Java code for the above approach

import java.io.*;

class Main {

  static boolean searchInMatrix(int[][] arr, int x)
  {
    int m = arr.length, n = arr[0].length;

    for (int i = 0; i < m; i++) {
      for (int j = 0; j < n; j++) {
        if (arr[i][j] == x)
          return true;
      }
    }
    return false;
  }

  public static void main(String[] args)
  {
    int x = 8;
    int[][] arr = { { 0, 6, 8, 9, 11 },
                   { 20, 22, 28, 29, 31 },
                   { 36, 38, 50, 61, 63 },
                   { 64, 66, 100, 122, 128 } };

    if (searchInMatrix(arr, x)) {
      System.out.println(""YES"");
    }
    else {
      System.out.println(""NO"");
    }
  }
}"
What are the applications of Matrix data structure?,"In Algorithms: Matrix are frequently used in problems based on Dynamic Programming Algorithm to store the answer to already computed states.
Image processing: Images can be represented as a matrix of pixels, where each pixel corresponds to an element in the matrix. This helps in preforming different operations on images.
Robotics: In robotics, matrices are used to represent the position and orientation of robots and their end-effectors. They are used to calculate the kinematics and dynamics of robot arms, and to plan their trajectories.
Transportation and logistics: Matrices are used in transportation and logistics to represent transportation networks and to solve optimization problems such as the transportation problem and the assignment problem.
Finance: Matrices are used in finance to represent portfolios of assets, to calculate the risk and return of investments, and to perform operations such as asset allocation and optimization.
Linear Algebra: Matrices are widely used in linear algebra, a branch of mathematics that deals with linear equations, vector spaces, and linear transformations. Matrices are used to represent linear equations and to solve systems of linear equations."
What are the advantages and disadvantages of Matrix data structures?,"Advantages of Matrix Data Structure:
It helps in 2D Visualization.
It stores multiple elements of the same type using the same name.
It enables access to items at random.
Any form of data with a fixed size can be stored.
It is easy to implement.
Disadvantages of Matrix Data Structure:
Space inefficient when we need to store very few elements in the matrix.
The matrix size should be needed beforehand.
Insertion and deletion operations are costly if shifting occurs.
Resizing a matrix is time-consuming."
How to traverse in multi dimensional array?,"import java.io.*;
 
class Main {
    public static void main(String[] args)
    {
        int n = 3;
        int m = 3;
        int[][] arr
            = { { 3, 2, 7 }, { 2, 6, 8 }, { 5, 1, 9 } };
 
        // Iterating over all 1-D arrays in 2-D array
        for (int i = 0; i < n; i++) {
            // Printing all elements of ith row
            for (int j = 0; j < m; j++) {
                System.out.print(arr[i][j] + "" "");
            }
            System.out.println();
        }
    }
}Time Complexity: O(n*m)
Auxiliary Space: O(1)"
What are searching algorithms?,"Searching algorithms are essential tools in computer science used to locate specific items within a collection of data. These algorithms are designed to efficiently navigate through data structures to find the desired information, making them fundamental in various applications such as databases, web search engines, and more.
"
what are the types of sorting?,"Linear Search
Sentinel Linear Search
Binary Search
Meta Binary Search | One-Sided Binary Search
Ternary Search
Jump Search
Interpolation Search
Exponential Search
Fibonacci Search
The Ubiquitous Binary Search"
Compare linear search and binary search,"LINEAR SEARCH

Assume that item is in an array in random order and we have to find an item. Then the only way to search for a target item is, to begin with, the first position and compare it to the target. If the item is at the same, we will return the position of the current item. Otherwise, we will move to the next position. If we arrive at the last position of an array and still can not find the target, we return -1. This is called the Linear search or Sequential search.                BINARY SEARCH

In a binary search, however, cut down your search to half as soon as you find the middle of a sorted list. The middle element is looked at to check if it is greater than or less than the value to be searched. Accordingly, a search is done to either half of the given list"
Linked list vs array,"Linked List:
Data Structure: Non-contiguous
Memory Allocation: Dynamic
Insertion/Deletion: Efficient
Access: Sequential
Array:
Data Structure: Contiguous
Memory Allocation: Static
Insertion/Deletion: Inefficient
Access: Random"
Difference Between Graph and Tree,"Key Differences Between Graph and Tree
Cycles: Graphs can contain cycles, while trees cannot.
Connectivity: Graphs can be disconnected (i.e., have multiple components), while trees are always connected.
Hierarchy: Trees have a hierarchical structure, with one vertex designated as the root. Graphs do not have this hierarchical structure.
Applications: Graphs are used in a wide variety of applications, such as social networks, transportation networks, and computer science. Trees are often used in hierarchical data structures, such as file systems and XML documents."
Properties of a Trie Data Structure,"Below are some important properties of the Trie data structure:

Each Trie has an empty root node, with links (or references) to other nodes
Each node of a Trie represents a string and each edge represents a character.
Every node consists of hashmaps or an array of pointers, with each index representing a character and a flag to indicate if any string ends at the current node.
Trie data structure can contain any number of characters including alphabets, numbers, and special characters. But for this article, we will discuss strings with characters a-z. Therefore, only 26 pointers need for every node, where the 0th index represents ‘a’ and the 25th index represents ‘z’ characters.
Each path from the root to any node represents a word or string."
How does Trie Data Structure work?,"Trie data structure can contain any number of characters including alphabets, numbers, and special characters. But for this article, we will discuss strings with characters a-z. Therefore, only 26 pointers need for every node, where the 0th index represents ‘a’ and the 25th index represents ‘z’ characters.

Any lowercase English word can start with a-z, then the next letter of the word could be a-z, the third letter of the word again could be a-z, and so on. "
what are the basic operations on trie data structure?,"Basic Operations on Trie Data Structure:
Insertion
Search
Deletion"
give implementation of Insertion in Trie data structure.,"Algorithm:

Define a function insert(TrieNode *root, string &word) which will take two parameters one for the root and the other for the string that we want to insert in the Trie data structure.
Now take another pointer currentNode and initialize it with the root node.
Iterate over the length of the given string and check if the value is NULL or not in the array of pointers at the current character of the string.
If It’s NULL then, make a new node and point the current character to this newly created node.
Move the curr to the newly created node.
Finally, increment the wordCount of the last currentNode, this implies that there is a string ending currentNode.                                                                                                                                                                                     static void insert(TrieNode root, String key)
{
    // Initialize the currentNode pointer with the root node
    TrieNode currentNode = root;

    for (int i = 0; i < key.length(); i++) {
        int index = key.charAt(i) - 'a';

        // Check if the node exist for the current
        // character in the Trie.
        if (currentNode.childNode[index] == null) {

            // Keep the reference for the newly created
            // node.
            currentNode.childNode[index] = new TrieNode();
        }

        // Now, move the current node pointer to the newly
        // created node.
        currentNode = currentNode.childNode[index];
    }

    // Increment the wordEndCount for the last currentNode
    // pointer this implies that there is a string ending at
    // currentNode.
    currentNode.wordCount++;
}
"
give implementation for deletion in trie data structure.,"Deletion in Trie Data Structure:  This operation is used to delete strings from the Trie data structure. There are three cases when deleting a word from Trie.

The deleted word is a prefix of other words in Trie.
The deleted word shares a common prefix with other words in Trie.
The deleted word does not share any common prefix with other words in Trie."
What is Dynamic Programming (DP)?,"Dynamic Programming (DP) is a method used in mathematics and computer science to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems."
"give approaches of Dynamic Programming (DP)
","Dynamic programming can be achieved using two approaches:

1. Top-Down Approach (Memoization):
In the top-down approach, also known as memoization, we start with the final solution and recursively break it down into smaller subproblems. To avoid redundant calculations, we store the results of solved subproblems in a memoization table.

Let’s breakdown Top down approach:

Starts with the final solution and recursively breaks it down into smaller subproblems.
Stores the solutions to subproblems in a table to avoid redundant calculations.
Suitable when the number of subproblems is large and many of them are reused.
2. Bottom-Up Approach (Tabulation):
In the bottom-up approach, also known as tabulation, we start with the smallest subproblems and gradually build up to the final solution. We store the results of solved subproblems in a table to avoid redundant calculations.

Let’s breakdown Bottom-up approach:

Starts with the smallest subproblems and gradually builds up to the final solution.
Fills a table with solutions to subproblems in a bottom-up manner.
Suitable when the number of subproblems is small and the optimal solution can be directly computed from the solutions to smaller subproblems."
what are the advantages of dynamic programming?,"Adavantages of dynamic programming: 

Avoids recomputing the same subproblems multiple times, leading to significant time savings.
Ensures that the optimal solution is found by considering all possible combinations.
Breaks down complex problems into smaller, more manageable subproblems.
  "
what are divide and conquer algorithms,"Divide and Conquer is a problem-solving strategy that involves breaking down a complex problem into smaller, more manageable parts, solving each part individually, and then combining the solutions to solve the original problem. It is a widely used algorithmic technique in computer science and mathematics.

Example: In the Merge Sort algorithm, the “Divide and Conquer” strategy is used to sort a list of elements. Below image illustrate the dividing and merging states to sort the array using Merge Sort."
What are the Stages of Divide and Conquer?,"Divide and Conquer Algorithm can be divided into three stages: Divide, Conquer and Merge.

1. Divide:
Break down the original problem into smaller subproblems.
Each subproblem should represent a part of the overall problem.
The goal is to divide the problem until no further division is possible.
2. Conquer:
Solve each of the smaller subproblems individually.
If a subproblem is small enough (often referred to as the “base case”), we solve it directly without further recursion.
The goal is to find solutions for these subproblems independently.
3. Merge:
Combine the sub-problems to get the final solution of the whole problem.
Once the smaller subproblems are solved, we recursively combine their solutions to get the solution of larger problem.
The goal is to formulate a solution for the original problem by merging the results from the subproblems."
What is Segment Tree?,"Segment Tree is a data structure that stores data about range of elements in nodes as a tree. It is mostly used to handle range queries with updates in an efficient manner. For example, we can perform a range summation of an array between the range L to R while also modifying the array from range L to R all in log(N) time complexity."
what are the operations segment tree can perform?,"The operations that the segment tree can perform must be binary and associative. Some of the examples of operations are:

Finding Range Sum Queries
Searching index with given prefix sum
Finding Range Maximum/Minimum
Counting frequency of Range Maximum/Minimum
Finding Range GCD/LCM
Finding Range AND/OR/XOR
Finding number of zeros in the given range or finding index of Kth zero"
What are the applications of segment trees?,"Interval scheduling: Segment trees can be used to efficiently schedule non-overlapping intervals, such as scheduling appointments or allocating resources.
Range-based statistics: Segment trees can be used to compute range-based statistics such as variance, standard deviation, and percentiles.
Image processing: Segment trees are used in image processing algorithms to divide an image into segments based on color, texture, or other attributes."
Give implementation of segment tree,"Code in Java: public class SegmentTree {
    private int[] segmentTree;
    private int[] nums;

    public SegmentTree(int[] nums) {
        this.nums = nums;
        int n = nums.length;
        int height = (int) Math.ceil(Math.log(n) / Math.log(2));
        int maxSize = 2 * (int) Math.pow(2, height) - 1;
        segmentTree = new int[maxSize];
        buildSegmentTree(0, 0, n - 1);
    }

    private void buildSegmentTree(int index, int start, int end) {
        if (start == end) {
            segmentTree[index] = nums[start];
            return;
        }
        int mid = start + (end - start) / 2;
        buildSegmentTree(2 * index + 1, start, mid);
        buildSegmentTree(2 * index + 2, mid + 1, end);
        segmentTree[index] = segmentTree[2 * index + 1] + segmentTree[2 * index + 2];
    }

    public void update(int index, int newValue) {
        int diff = newValue - nums[index];
        nums[index] = newValue;
        updateSegmentTree(0, 0, nums.length - 1, index, diff);
    }

    private void updateSegmentTree(int index, int start, int end, int idx, int diff) {
        if (idx < start || idx > end) {
            return;
        }
        segmentTree[index] += diff;
        if (start != end) {
            int mid = start + (end - start) / 2;
            updateSegmentTree(2 * index + 1, start, mid, idx, diff);
            updateSegmentTree(2 * index + 2, mid + 1, end, idx, diff);
        }
    }

    public int sumRange(int left, int right) {
        return querySegmentTree(0, 0, nums.length - 1, left, right);
    }

    private int querySegmentTree(int index, int start, int end, int left, int right) {
        if (right < start || left > end) {
            return 0;
        }
        if (left <= start && right >= end) {
            return segmentTree[index];
        }
        int mid = start + (end - start) / 2;
        return querySegmentTree(2 * index + 1, start, mid, left, right) +
               querySegmentTree(2 * index + 2, mid + 1, end, left, right);
    }

    public static void main(String[] args) {
        int[] nums = {1, 3, 5, 7, 9, 11};
        SegmentTree segmentTree = new SegmentTree(nums);
        System.out.println(segmentTree.sumRange(1, 3)); // Output: 15
        segmentTree.update(1, 10);
        System.out.println(segmentTree.sumRange(1, 3)); // Output: 22
    }
}
Explanation:

The Segment Tree is a data structure that allows efficient querying and updating of intervals or segments of an array.
In this implementation, the constructor builds the segment tree recursively by dividing the array into halves until each segment represents a single element.
The update method updates a single element in the array and recalculates the corresponding segment tree nodes.
The sumRange method calculates the sum of elements within a given range using the segment tree.
The main method demonstrates the usage of the Segment Tree by initializing it with an array, performing a range sum query, and updating an element in the array."